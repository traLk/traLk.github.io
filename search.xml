<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【NOTES-02】StreamCihper-线性同余生成器</title>
      <link href="2021/05/20/79ad8360e731/"/>
      <url>2021/05/20/79ad8360e731/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在学习流密码，看CTFWiki的过程中有一些疑问和理解，就记录下来方便之后查阅</p></blockquote><h1 id="Method-One"><a href="#Method-One" class="headerlink" title="Method One"></a>Method One</h1><p>程序的大概意思就是一个猜数游戏，如果连续猜中若干次，就算会拿到 flag，背后的生成相应数的核心代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># generate seed with 64 bits of entropy</span></span><br><span class="line">        self.p = <span class="number">4646704883L</span></span><br><span class="line">        self.x = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        self.y = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">        self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line">        <span class="keyword">return</span> (self.x ^ self.y)</span><br></pre></td></tr></table></figure><p>显然，我们猜出前两轮还是比较容易的，毕竟概率也有 0.25。这里当我们猜出前两轮后，使用 Z3 来求解出初始的 x 和 y，那么我们就可以顺利的猜出剩下的值了。不妨进行一波数学推导</p><p><strong>注：$\bigoplus$表示异或</strong></p><script type="math/tex; mode=display">p = 4646704883\\x_0 = random.randint(0, p)\\y_0 = random.randint(0, p)\\x_1 = (2x_0 + 3) \% p\\y_1 = (3y_0 + 9) \% p\\sol_1 = x_1 \bigoplus y_1\\x_2 = (2x_1 + 3) \% p = (2((2x_0 + 3) \% p) + 3) \% p\\y_2 = (3y_1 + 9) \% p = (3((3x_0 + 9) \% p) + 9) \% p\\sol_2 = x_2 \bigoplus y_2</script><p>思路大概就是，如果能猜到$sol_1$和$sol_2$，就能直接得到$x_0$和$y_0$，如此以来，就能算得所有的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">s1cor = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>]) <span class="comment"># 运行程序的时候直接附上猜得的两个值</span></span><br><span class="line">s2cor = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">dimVector =<span class="number">35</span> <span class="comment"># <span class="doctag">TODO:</span> 事实上p只有33bits，不知道这里为什么要设成35bits</span></span><br><span class="line">x = BitVec(<span class="string">&#x27;x&#x27;</span>, dimVector)</span><br><span class="line">y = BitVec(<span class="string">&#x27;y&#x27;</span>, dimVector)</span><br><span class="line">p = BitVec(<span class="string">&#x27;p&#x27;</span>,dimVector)</span><br><span class="line">s1 = BitVec(<span class="string">&#x27;s1&#x27;</span>,dimVector)</span><br><span class="line">s2 = BitVec(<span class="string">&#x27;s2&#x27;</span>,dimVector)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(p == <span class="number">4646704883L</span>)</span><br><span class="line">s.add(s1 == s1cor)</span><br><span class="line">s.add(s2== s2cor)</span><br><span class="line">s.add( ( ( ( <span class="number">2</span> * x + <span class="number">3</span> ) % p ) ^ ( ( <span class="number">3</span> * y + <span class="number">9</span> ) % p ) )==s1)</span><br><span class="line">s.add(( ( ( <span class="number">2</span> * ( ( <span class="number">2</span> * x + <span class="number">3</span> ) % p )  + <span class="number">3</span> ) % p ) ^ ( ( <span class="number">3</span> * ( (  <span class="number">3</span> * y + <span class="number">9</span> ) % p) + <span class="number">9</span> ) % p ) )==s2)</span><br><span class="line"><span class="keyword">while</span> s.check() == sat:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">self.p = <span class="number">4646704883L</span></span><br><span class="line">self.x = x</span><br><span class="line">self.y = y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line"><span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getX</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getY</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.y</span><br><span class="line">m = s.model() <span class="comment"># 解向量</span></span><br><span class="line">pMy = <span class="number">4646704883L</span></span><br><span class="line">myObj = SecurePrng(<span class="built_in">int</span>(<span class="built_in">str</span>(m[x]))%pMy,<span class="built_in">int</span>(<span class="built_in">str</span>(m[y]))%pMy) <span class="comment"># 直接将解传进去，得到下一个结果。事实上这一步是验证解，因为可能有多组解</span></span><br><span class="line">mySol1 = myObj.<span class="built_in">next</span>()</span><br><span class="line">mySol2 = myObj.<span class="built_in">next</span>()</span><br><span class="line"><span class="keyword">if</span> mySol1 == s1cor <span class="keyword">and</span> mySol2 == s2cor <span class="keyword">and</span> <span class="built_in">int</span>(<span class="built_in">str</span>(m[x]))&lt;= pMy <span class="keyword">and</span> <span class="built_in">int</span>(<span class="built_in">str</span>(m[y])) &lt;= pMy :</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;x = &quot;</span> + <span class="built_in">str</span>(m[x]) + <span class="string">&quot; ; y = &quot;</span> + <span class="built_in">str</span>(m[y]) </span><br><span class="line">s.add(Or(x != s.model()[x], y != s.model()[y]))</span><br></pre></td></tr></table></figure><p>下面可以重写PRNG，达到利用的目的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">self.i = <span class="number">0</span></span><br><span class="line">self.p = <span class="number">4646704883L</span></span><br><span class="line">self.x = <span class="number">3714993585</span> % self.p</span><br><span class="line">self.y = <span class="number">2248563082</span> % self.p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="built_in">print</span> self.i</span><br><span class="line">self.i += <span class="number">1</span></span><br><span class="line">self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line"><span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getX</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getY</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.y</span><br></pre></td></tr></table></figure><h1 id="Method-Two"><a href="#Method-Two" class="headerlink" title="Method Two"></a>Method Two</h1><p>上面的方法是很好理解的，但CTFWiki上提供了另外一种方法，目前看来是一种更加值得记录下来，好好理解的方法</p><p>下面是原文摘录</p><blockquote><p>这里我们考虑另外一种方法，<strong>依次从低比特位枚举到高比特位获取 x 的值</strong>，之所以能够这样做，是依赖于这样的观察</p><ul><li>a + b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。<strong>因为第 i 比特位进行运算时，只有可能收到低比特位的进位数值。</strong></li><li>a - b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。<strong>因为第 i 比特位进行运算时，只有可能向低比特位的借位。</strong></li><li>a * b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为这可以视作多次加法。</li><li>a % b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为这可视为多次进行减法。</li><li>a ^ b = c，c 的第 i 比特位的值只受 a 和 b 该比特位的影响。这一点是显而易见的。</li></ul><p><strong>注：个人感觉这个技巧非常有用。</strong></p><p>此外，我们不难得知 p 的比特位为 33 比特位。具体利用思路如下</p><ol><li>首先获取两次猜到的值，这个概率有 0.25。</li><li>依次从低比特位到高比特位依次枚举<strong>第一次迭代后的 x 的相应比特位</strong>。</li><li>根据自己枚举的值分别计算出第二次的值，只有当对应比特位正确，可以将其加入候选正确值。需要注意的是，这里由于取模，所以我们需要枚举到底减了多少次。</li><li>此外，在最终判断时，仍然需要确保对应的值满足一定要求，因为之前对减了多少次进行了枚举。</li></ol></blockquote><p><strong>注：我们主要关注利用思路的第二、三、四三步</strong></p><p>具体利用代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=-<span class="number">1</span>, y=-<span class="number">1</span></span>):</span> <span class="comment"># 题外话，默认值参数真是一个美妙的东西，利用好了可以用来做cache、condition啥的</span></span><br><span class="line">        <span class="comment"># generate seed with 64 bits of entropy</span></span><br><span class="line">        self.p = <span class="number">4646704883L</span>  <span class="comment"># 33bit</span></span><br><span class="line">        <span class="keyword">if</span> x == -<span class="number">1</span>:</span><br><span class="line">            self.x = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.x = x</span><br><span class="line">        <span class="keyword">if</span> y == -<span class="number">1</span>:</span><br><span class="line">            self.y = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">        self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line">        <span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbiti</span>(<span class="params">num, idx</span>):</span> <span class="comment"># idx表达一个类似长度的量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(num)[-idx - <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sp = SecurePrng()</span><br><span class="line">    targetx = sp.x</span><br><span class="line">    targety = sp.y</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;we would like to get x &quot;</span>, targetx</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;we would like to get y &quot;</span>, targety</span><br><span class="line"></span><br><span class="line">    <span class="comment"># suppose we have already guess two number</span></span><br><span class="line">    guess1 = sp.<span class="built_in">next</span>()</span><br><span class="line">    guess2 = sp.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">    p = <span class="number">4646704883</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># newx = tmpx*2+3-kx*p</span></span><br><span class="line">    <span class="keyword">for</span> kx, ky <span class="keyword">in</span> product(<span class="built_in">range</span>(<span class="number">3</span>), <span class="built_in">range</span>(<span class="number">4</span>)): <span class="comment"># 双重循环</span></span><br><span class="line">        candidate = [[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># only 33 bit</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>): <span class="comment"># 第三层循环</span></span><br><span class="line">            <span class="comment">#print &#x27;idx &#x27;, i</span></span><br><span class="line">            new_candidate = []</span><br><span class="line">            <span class="keyword">for</span> old, bit <span class="keyword">in</span> product(candidate, <span class="built_in">range</span>(<span class="number">2</span>)): <span class="comment"># 最深双层循环</span></span><br><span class="line">                <span class="comment">#print old, bit</span></span><br><span class="line">                oldx = old[<span class="number">0</span>]</span><br><span class="line">                <span class="comment">#oldy = old[1]</span></span><br><span class="line">                tmpx = oldx | ((bit &amp; <span class="number">1</span>) &lt;&lt; i) <span class="comment"># <span class="doctag">TODO:</span> 这个遍历方法还需要理解...</span></span><br><span class="line">                <span class="comment">#tmpy = oldy | ((bit / 2) &lt;&lt; i)</span></span><br><span class="line">                tmpy = tmpx ^ guess1 <span class="comment"># seed_x与第一次猜测的结果异或，得到的就是seed_y</span></span><br><span class="line">                newx = tmpx * <span class="number">2</span> + <span class="number">3</span> - kx * p + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>) <span class="comment"># <span class="doctag">TODO:</span> 后面判断的时候也加上了这个条件，这不等价于啥也没干？暂时不太懂</span></span><br><span class="line">                newy = tmpy * <span class="number">3</span> + <span class="number">9</span> - ky * p + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>)</span><br><span class="line">                tmp1 = newx ^ newy</span><br><span class="line">                <span class="comment">#print &quot;tmpx:    &quot;, bin(tmpx)</span></span><br><span class="line">                <span class="comment">#print &quot;targetx: &quot;, bin(targetx)</span></span><br><span class="line">                <span class="comment">#print &quot;calculate:     &quot;, bin(tmp1 + (1 &lt;&lt; 40))</span></span><br><span class="line">                <span class="comment">#print &quot;target guess2: &quot;, bin(guess1 + (1 &lt;&lt; 40))</span></span><br><span class="line">                <span class="keyword">if</span> getbiti(guess2 + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>), i) == getbiti( <span class="comment"># 验证条件，并加入候选解</span></span><br><span class="line">                        tmp1 + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>), i):</span><br><span class="line">                    <span class="keyword">if</span> [tmpx] <span class="keyword">not</span> <span class="keyword">in</span> new_candidate:</span><br><span class="line">                        <span class="comment">#print &quot;got one&quot;</span></span><br><span class="line">                        <span class="comment">#print bin(tmpx)</span></span><br><span class="line">                        <span class="comment">#print bin(targetx)</span></span><br><span class="line">                        <span class="comment">#print bin(tmpy)</span></span><br><span class="line">                        new_candidate.append([tmpx])</span><br><span class="line">            candidate = new_candidate</span><br><span class="line">            <span class="comment">#print len(candidate)</span></span><br><span class="line">            <span class="comment">#print candidate</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;candidate x for kx: &quot;</span>, kx, <span class="string">&quot; ky &quot;</span>, ky</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> candidate: <span class="comment"># 依次验证每个候选解是否由线性同余生成器生成</span></span><br><span class="line">            tmpx = candidate[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            tmpy = tmpx ^ guess1</span><br><span class="line">            <span class="keyword">if</span> tmpx &gt;= p <span class="keyword">or</span> tmpx &gt;= p:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            mysp = SecurePrng(tmpx, tmpy)</span><br><span class="line">            tmp1 = mysp.<span class="built_in">next</span>()</span><br><span class="line">            <span class="keyword">if</span> tmp1 != guess2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">print</span> tmpx, tmpy</span><br><span class="line">            <span class="built_in">print</span>(targetx * <span class="number">2</span> + <span class="number">3</span>) % p, (targety * <span class="number">3</span> + <span class="number">9</span>) % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF-Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Cryptography </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOTES-01】The Elementary of Programming Style</title>
      <link href="2021/05/19/d7392dfa38f0/"/>
      <url>2021/05/19/d7392dfa38f0/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Elementary-of-Programming-Style"><a href="#The-Elementary-of-Programming-Style" class="headerlink" title="The Elementary of Programming Style"></a>The Elementary of Programming Style</h1><blockquote><p>转载自RX师傅的博客<a href="https://www.wootec.top/2019/08/18/The-Elementary-Of-Programming-Style/">The Elementary Of Programming Style - Reverier’s Blog (wootec.top)</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是网上流行的一本绝版书籍,短短几页却浓缩了很多精华.</p><p>即使过了30余年, 其中的思想仍旧在编程时十分有参考价值. 时间挡不住作者的真知灼见.</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>对其中一些内容做了一些注释，方便后面自己看的时候能发现想法的变化</p></blockquote><ul><li><p>把代码写清楚，别耍小聪明。</p><blockquote><p>如果有这种才能，建议出成一个带混淆的逆向题（逃</p></blockquote></li><li><p>想干什么，讲的简单点、直接点。</p><blockquote><p>同上，包括你的命名，函数名，代码结构</p></blockquote></li><li><p>只要有可能，使用库函数。</p><blockquote><p>经常去康康库函数源码，反正我是惊呆了，目前的感受就是在使用python的时候告诉自己，多使用built-in function，能显著简化代码</p></blockquote></li><li><p>避免使用太多的临时变量。</p><blockquote><p>什么tmp啊，temp啊，建议少用点，让人觉得很啰嗦</p></blockquote></li><li><p>“效率”不是牺牲清晰性的理由。</p><blockquote><p>确实，有的时候工程代码和竞赛代码不能一概而论，不要顾此失彼</p></blockquote></li><li><p>让机器去干那些脏活。</p><blockquote><p>emmmmm不解释了，应该懂得</p></blockquote></li><li><p>重复的表达式应该换成函数调用。</p><blockquote><p>这个也是老生常谈了，这样的去重方便了调试，也方便了代码复用</p></blockquote></li><li><p>加上括号、避免歧义。</p><blockquote><p>写c的时候不要因为if后面只有一个表达式就省略大括号</p></blockquote></li><li><p>不要使用含糊不清的变量名。</p><blockquote><p>a, b, c… 完了高血压来了</p></blockquote></li><li><p>把不必要的分支去掉。</p><blockquote><p>这个可能需要一些离散数学的知识，能将一大坨条件判断进行谓词逻辑的等价变换，从而化简分支。事实上很多混淆也是基于这个思路</p></blockquote></li><li><p>使用语言的好特性，不要使用那些糟糕的特性。</p><blockquote><p>目前接触到的语言有限，暂时想到的是python中的各种内置数据结构，可以轻松实现类似有向图的存储等等</p></blockquote></li><li><p>该用逻辑表达式的时候，不要使用过多的条件分支。</p></li><li><p>如果逻辑表达式不好理解，就试着做下变形。</p></li><li><p>选择让程序更简洁的数据表达形式。</p></li><li><p>先用伪代码写，再翻译成你使用的语言。</p><blockquote><p>这就是手写代码的威力啦，不但能用来锻炼对代码的理解，还能用来预构建思路噢</p></blockquote></li><li><p>模块化。使用过程和函数。</p><blockquote><p>建议学习Common Lisp或Scheme类似的极致函数式编程语言，学完感觉看世界都不一样了（虽然我现在有点忘记</p></blockquote></li><li><p>只要你能保证程序的可读性，能不用 goto 就别用 。</p><blockquote><p>逆向中碰到goto的话，会觉得非常莫名其妙，突然就跑飞了。所以同样的，建议出成题目</p></blockquote></li><li><p>不要给糟糕的代码打补丁 - 重写就是了。</p></li><li><p>把大的程序分成一小片一小片来写，分块测试。</p></li><li><p>使用递归程序来处理递归定义的数据结构。</p></li><li><p>正确和错误的输入数据都要测试。</p></li><li><p>确保输入不会超出程序的限制。</p></li><li><p>依靠文件结束来终止输入，而不是依赖一个记数。</p></li><li><p>把文件结束作为一个输入状态来处理。</p></li><li><p>识别出错误的输入；如果有可能就修复它。</p></li><li><p>让输入数据很容易构造出来，让输出数据不言自明。</p></li><li><p>使用统一的输入格式。</p></li><li><p>让输入容易校对。</p></li><li><p>如有可能，提供更自由的输入格式。</p></li><li><p>使用输入提示，允许使用默认值。并把它们显示出来。</p></li><li><p>把输入输出放到子程序里。</p></li><li><p>确保所有的变量在使用前都有初始化。</p></li><li><p>不要因为一个 bug 而停止不前。</p></li><li><p>打开编译程序的调试选项。</p><blockquote><p>对反逆向工程有一点帮助，因为debug模式发布的程序，它的汇编和release版本有很大的差别</p></blockquote></li><li><p>常量结构用数据声明初始化，变量结构用执行代码初始化。</p></li><li><p>小心 off-by-one 错误。</p></li><li><p>当循环中有多个跳出点时要小心。</p></li><li><p>如果什么都不做，那么也要优雅的表现出这个意思。</p></li><li><p>用边界值测试程序。</p><blockquote><p>尽可能刁难你的代码，想一些脑溢血（bushi，才会想到的测试值</p></blockquote></li><li><p>手工检查一些答案。</p><blockquote><p>不管是不是手工吧，你要在脑子里跑一会儿你的程序，以检查时候符合你的预期值</p></blockquote></li><li><p>防御式编程 - 为不可能的情况写几句代码。</p></li><li><p>10.0 乘 0.1 很难保证永远是 1.0 。</p></li><li><p>7/8 等于 0 ，而 7.0/8.0 不等于 0 。</p></li><li><p>不要直接判断两个浮点数相等。</p></li><li><p>先做对，再弄快。</p></li><li><p>先使其可靠，再让其更快。</p></li><li><p>先把代码弄干净，再让它变快。</p></li><li><p>别为了获得一丁点“性能”就牺牲掉整洁。</p></li><li><p>让编译器做些简单的优化。</p><blockquote><p>编译器是很强大的，以gcc为例，有很多关于安全的意想不到的功能</p></blockquote></li><li><p>不要过分追求重用代码；下次用的时候重新组织一下即可。</p></li><li><p>确保特殊的情况是真的特殊。</p><blockquote><p>这个是真的，不要突然考虑到一个情况，就写一个另外的分支；又想到一种情况，又写一个分支…</p></blockquote></li><li><p>保持简洁以获得速度。</p></li><li><p>不要死磕代码来加快速度 - 找个更好的算法。</p></li><li><p>用工具分析你的程序。在做“性能”改进前先评测一下。</p></li><li><p>确保注释和代码一致。</p></li><li><p>不要在注释里仅仅重复代码 - 让每处注释都有价值。</p></li><li><p>不要给糟糕的代码做注释 - 应该重写它。</p><blockquote><p>szyd，至于怎么算糟糕，这个应该能感觉出来吧（</p></blockquote></li><li><p>给变量都起个有意义的名字。</p><blockquote><p>array不如换成src或者dest</p></blockquote></li><li><p>把程序重新整理一下，让阅读代码的人更容易理解。</p><blockquote><p>代码重构是很累的（反正我是这样，但没办法啊，必须得肝</p></blockquote></li><li><p>为你的数据布局写一个文档。</p><blockquote><p>这个暂时没啥想法，类似Android里面的xml？I don’t know…</p></blockquote></li><li><p>不要过分注释。</p><blockquote><p>在《代码简洁之道》中有对于这个的详细解释。因为写的代码一定会有后期维护哒，所以注释不用写得过于详细，比如说对于某个函数，只需要记录他的大致作用就行，而不需要记录诸如，这个变量是干嘛的，那个变量又是干嘛的。因为人都是比较懒的，维护代码的时候，如果你看到的是你一年前写的又臭又长的注释，你会想管它吗？大概率不会。然后受伤的就是用户了</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Style </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming Style </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-02】MiniL-CTF-2021</title>
      <link href="2021/05/16/e9933c575dd2/"/>
      <url>2021/05/16/e9933c575dd2/</url>
      
        <content type="html"><![CDATA[<h1 id="Mini-L2021"><a href="#Mini-L2021" class="headerlink" title="Mini-L2021"></a>Mini-L2021</h1><p><strong>URL</strong>: <a href="https://ctf.xidian.edu.cn/#/index">https://ctf.xidian.edu.cn/#/index</a></p><p><strong>Team</strong>: cuttl3fish——kyriota | track | TBMK</p><p><strong>Start Time</strong>: 5.06 20:00</p><p><strong>End Time</strong>: 5.12 20:00</p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="web1-easy-java-kyr"><a href="#web1-easy-java-kyr" class="headerlink" title="web1 easy-java | kyr"></a>web1 easy-java | kyr</h3><p>不会java，枯嘞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">New java.io.BufferedReader(New java.io.FileReader(<span class="string">&quot;/flag&quot;</span>)).readLine()</span><br></pre></td></tr></table></figure><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="抓猫猫-kyr"><a href="#抓猫猫-kyr" class="headerlink" title="抓猫猫 | kyr"></a>抓猫猫 | kyr</h3><blockquote><p> hint：kawaii neko chan says that : what doesn’t kill u makes u stronger</p></blockquote><p>so what u should do is follow what she said , 然后同时连俩 bot 让他们对线，看看谁更腻害</p><h3 id="好白给的签到题-kyr"><a href="#好白给的签到题-kyr" class="headerlink" title="好白给的签到题 | kyr"></a>好白给的签到题 | kyr</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;story.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    fll=flast</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;&#123;&#x27;</span> <span class="keyword">in</span> f <span class="keyword">and</span> <span class="string">b&#x27;&#125;&#x27;</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(f[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        flast=f</span><br><span class="line">        f=base64.b64decode(f)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        flast=fll</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f=base64.b64decode(f[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            f=base64.b64decode(flast[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="土-块-kyr"><a href="#土-块-kyr" class="headerlink" title="土 块 | kyr"></a>土 块 | kyr</h3><p>把题目中的<code>game</code>函数拿出来研究，如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tukuai <span class="keyword">import</span> game</span><br><span class="line">cheat=[[<span class="number">9</span>,[<span class="number">1</span>,<span class="number">0</span>]],[<span class="number">9</span>,[<span class="number">0</span>,<span class="number">1</span>]]]</span><br><span class="line">init_state = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">coin1 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">coin2 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">temp = coin1 * <span class="number">2</span> + coin2</span><br><span class="line">init_state[temp] = <span class="number">1</span></span><br><span class="line">servercoin,qc = game(cheat, init_state)</span><br><span class="line"><span class="built_in">print</span>(coin1)</span><br><span class="line"><span class="built_in">print</span>(coin2)</span><br><span class="line"><span class="built_in">print</span>(init_state)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my coin is &#x27;</span> + <span class="built_in">str</span>(servercoin) + <span class="string">&#x27; your coin is?&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_bloch_multivector</span><br><span class="line">display(plot_bloch_multivector(init_state))</span><br><span class="line">simulator=Aer.get_backend(<span class="string">&#x27;qasm_simulator&#x27;</span>)</span><br><span class="line">result=execute(qc,backend=simulator).result()</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_histogram</span><br><span class="line">display(qc.draw(output=<span class="string">&#x27;mpl&#x27;</span>))</span><br><span class="line">display(plot_histogram(result.get_counts(qc)))</span><br></pre></td></tr></table></figure><p>画出几个图出来看看，只要绘出 bot 的输出 = my coin 的量子电路即可，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌──────────────────────┐┌───┐        </span><br><span class="line">q12_0: ┤0                     ├┤ X ├──■─────</span><br><span class="line">       │  initialize(0,0,1,0) │└─┬─┘┌─┴─┐┌─┐</span><br><span class="line">q12_1: ┤1                     ├──■──┤ X ├┤M├</span><br><span class="line">       └──────────────────────┘     └───┘└╥┘</span><br><span class="line"> c1: 1&#x2F;═══════════════════════════════════╩═</span><br><span class="line">                                          0 </span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="0oooops-track"><a href="#0oooops-track" class="headerlink" title="0oooops | track"></a>0oooops | track</h3><blockquote><p>这道题涉及到windows的异常处理机制SEH</p></blockquote><h4 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h4><p>这个题不涉及太多SEH的底层，大概有以下几个点需要了解的：</p><ul><li>SEH实际包含两个主要功能：结束处理（termination handling）和异常处理（exception handling)</li><li>每当你建立一个try块，它必须跟随一个 <code>__finally</code>块或一个<code>__except</code>块。</li><li>一个<code>try</code>块之后不能既有finally块又有except块。但可以在try-except块中嵌套try-finally块，反过来 也可以。</li><li><code>__try</code>,<code>__finally</code>关键字用来标出结束处理程序两段代码的轮廓<br>不管保护体（try块） 是如何退出的。不论你在保护体中使用return，还是goto，或者是longjump，结束处理程序 （finally块）都将被调用。</li><li>在try使用<code>__leave</code>关键字会引起跳转到try块的结尾</li><li>给<code>ms_exc.registration.TryLevel</code>赋值是用于处理嵌套的try</li></ul><blockquote><p>学习自HAPPY师傅的博客</p></blockquote><p>然后看看题，main函数直接看发现异常，于是看汇编，定位到伪代码异常处。IDA的分析结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00412330 loc_412330:                             ; CODE XREF: _main_0+15C↑j</span><br><span class="line">.text:00412330 ;   __try &#123; &#x2F;&#x2F; __except at loc_412377</span><br><span class="line">.text:00412330                 mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:00412337                 lea     ebx, [ebp+Str]</span><br><span class="line">.text:0041233D                 xor     eax, eax</span><br><span class="line">.text:0041233F                 db      3Eh</span><br><span class="line">.text:0041233F                 mov     dword ptr [eax], 0</span><br><span class="line">.text:00412346                 mov     edx, 0</span><br><span class="line">.text:0041234B                 div     edx</span><br></pre></td></tr></table></figure><p>发现非常明显的<strong>除零异常</strong>还有<strong>eax清零后却试图访问它的内存</strong>，以及SEH结构。不需要对它进行任何patch，因为必须让程序捕获到这个异常，才会去执行<code>__except_filter</code>，也就是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text:00412356 loc_412356:                             ; DATA XREF: .rdata:stru_41A238↓o</span><br><span class="line">.text:00412356 ;   __except filter &#x2F;&#x2F; owned by 412330</span><br><span class="line">.text:00412356                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:00412359                 mov     ecx, [eax]</span><br><span class="line">.text:0041235B                 mov     edx, [ecx]</span><br><span class="line">.text:0041235D                 mov     [ebp+var_1BC], edx</span><br><span class="line">.text:00412363                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:00412366                 push    eax</span><br><span class="line">.text:00412367                 mov     ecx, [ebp+var_1BC]</span><br><span class="line">.text:0041236D                 push    ecx</span><br><span class="line">.text:0041236E                 call    sub_411131</span><br><span class="line">.text:00412373                 add     esp, 8</span><br><span class="line">.text:00412376                 retn</span><br></pre></td></tr></table></figure><p>稍微看一看<code>sub_411131</code>函数的内部逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_411DD0</span><span class="params">(<span class="keyword">int</span> a1, _EXCEPTION_POINTERS *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a2-&gt;ExceptionRecord-&gt;ExceptionCode != <span class="number">0xC0000094</span> ) <span class="comment">// 除零异常相应的异常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5 = (<span class="keyword">char</span> *)(a2-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>);</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != ((<span class="keyword">unsigned</span> __int8)a2-&gt;ContextRecord-&gt;Eip ^ ((v5[<span class="number">2</span> * i + <span class="number">1</span>] ^ <span class="number">0x4D</span>) - <span class="number">4</span>) ^ <span class="number">0x13</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a2-&gt;ContextRecord-&gt;Eip += <span class="number">54</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a2-&gt;ContextRecord-&gt;Eip += <span class="number">63</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现将运算结果存在v5中，但是只有奇数位，不妨试着还原一下（伪代码）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> magic_1[] = <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_1[i] ^ 0x13 ^ errr_addr)+4)^0x4d);</span></span><br><span class="line">        flag[<span class="number">2</span> * i + <span class="number">1</span>] = ((magic_1[i] ^ <span class="number">0x13</span> ^ errr_addr)+<span class="number">4</span>)^<span class="number">0x4d</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并且如果满足条件，将会改变eip的值，将进程从异常中跳出来，不妨看看跳到了哪里</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">0x41234B</span> + <span class="number">63</span>))</span><br></pre></td></tr></table></figure><p>那里是congratulations的提示信息，但很明显我们还没拿到完整的flag</p><h4 id="VEH-amp-amp-TLS"><a href="#VEH-amp-amp-TLS" class="headerlink" title="VEH &amp;&amp; TLS"></a>VEH &amp;&amp; TLS</h4><p>查看IDA的Exports窗口可以看到TlsCallback_0_0</p><blockquote><p>TLS，Thread Local Storage 线程局部存储，TLS回调函数的调用运行要先于PE代码执行，该特性使它可以作为一种反调试技术使用。</p><p>TLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据。</p></blockquote><p>return了一个奇怪的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID __stdcall <span class="title">TlsCallback_0_0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">return</span> AddVectoredExceptionHandler(<span class="number">1u</span>, Handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attributes: thunk</span></span><br><span class="line"><span class="function">LONG __stdcall <span class="title">Handler</span><span class="params">(struct _EXCEPTION_POINTERS *ExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_411BD0(ExceptionInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">sub_411BD0</span><span class="params">(_EXCEPTION_POINTERS *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h]</span></span><br><span class="line">  DWORD v4; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a1-&gt;ExceptionRecord-&gt;ExceptionCode != <span class="number">0xC0000005</span> ) <span class="comment">// 不可访问地址相应的异常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v4 = a1-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>;</span><br><span class="line">  v3[<span class="number">0</span>] = <span class="number">16</span>;</span><br><span class="line">  v3[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">  v3[<span class="number">2</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">  v3[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">  v3[<span class="number">6</span>] = <span class="number">4</span>;</span><br><span class="line">  v3[<span class="number">7</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">8</span>] = <span class="number">11</span>;</span><br><span class="line">  v3[<span class="number">9</span>] = <span class="number">5</span>;</span><br><span class="line">  v3[<span class="number">10</span>] = <span class="number">31</span>;</span><br><span class="line">  v3[<span class="number">11</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">12</span>] = <span class="number">33</span>;</span><br><span class="line">  v3[<span class="number">13</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">14</span>] = <span class="number">72</span>;</span><br><span class="line">  v3[<span class="number">15</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">16</span>] = <span class="number">6</span>;</span><br><span class="line">  v3[<span class="number">17</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">18</span>] = <span class="number">17</span>;</span><br><span class="line">  v3[<span class="number">19</span>] = <span class="number">69</span>;</span><br><span class="line">  v3[<span class="number">20</span>] = <span class="number">5</span>;</span><br><span class="line">  v3[<span class="number">21</span>] = <span class="number">62</span>;</span><br><span class="line">  v3[<span class="number">22</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">23</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">24</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">25</span>] = <span class="number">72</span>;</span><br><span class="line">  v3[<span class="number">26</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">27</span>] = <span class="number">69</span>;</span><br><span class="line">  v3[<span class="number">28</span>] = <span class="number">33</span>;</span><br><span class="line">  v3[<span class="number">29</span>] = <span class="number">31</span>;</span><br><span class="line">  v3[<span class="number">30</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v3[i] != (((*(<span class="keyword">char</span> *)(v4 + <span class="number">2</span> * i) ^ <span class="number">0x37</span>) + <span class="number">4</span>) ^ <span class="number">0x42</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a1-&gt;ContextRecord-&gt;Eip += <span class="number">66</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a1-&gt;ContextRecord-&gt;Eip += <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Handler显然是第二段解密），因为我实在是太菜了，又查了一下这个函数的功能，发现了另一个异常处理机制VEH</p><p>VEH处理流程</p><blockquote><ul><li>CPU捕获异常信息</li><li>通过KiDispatchException进行分发(EIP=KiUserExceptionDispatcher)</li><li>KiUserExceptionDispatcher调用RtIDispatchException.</li><li>RtIDispatchException查找VEH处理函数链表并调用相关处理函数</li><li>代码返回到KiUserExceptionDispatcher</li><li>调用ZwContinue再次进入0环(ZwContinue调用NtContinue,主要作用就是恢复 TRAPFRAME然后通过_KiServiceExit返回到3环)。</li><li>线程再次返回3环后,从修正后的位置开始执行</li></ul><p>学习自：<a href="https://blog.csdn.net/weixin_42052102/article/details/83540134">https://blog.csdn.net/weixin_42052102/article/details/83540134</a></p></blockquote><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p><strong>这样一来整个流程大致明了了</strong></p><ul><li>VEH抓到<code>0xC0000005</code></li><li>SEH抓到<code>0xC0000094</code></li><li>分别的flag在各自的handler里面</li></ul><p>脚本如下，写的比较乱</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> errr_addr = <span class="number">0x30234B</span>;</span><br><span class="line">    <span class="keyword">char</span> magic_1[] = <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_1[i] ^ 0x13 ^ errr_addr)+4)^0x4d);</span></span><br><span class="line">        flag[<span class="number">2</span> * i + <span class="number">1</span>] = ((magic_1[i] ^ <span class="number">0x13</span> ^ errr_addr)+<span class="number">4</span>)^<span class="number">0x4d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> magic_2[] = &#123;<span class="number">16</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">4</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">31</span>,<span class="number">46</span>,<span class="number">33</span>,<span class="number">46</span>,<span class="number">72</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">17</span>,<span class="number">69</span>,<span class="number">5</span>,<span class="number">62</span>,<span class="number">46</span>,<span class="number">24</span>,<span class="number">21</span>,<span class="number">72</span>,<span class="number">46</span>,<span class="number">69</span>,<span class="number">33</span>,<span class="number">31</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_2[i]^0x42)-4)^0x37);</span></span><br><span class="line">        flag[<span class="number">2</span> * i] = ((magic_2[i]^<span class="number">0x42</span>)<span class="number">-4</span>)^<span class="number">0x37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    <span class="comment">// miniLctf&#123;y0u_a1r4ady_und4rstand_th4_w1nd0ws_exc4pt1On_handl1e_m4chan1sm&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sub-track"><a href="#sub-track" class="headerlink" title="sub | track"></a>sub | track</h3><blockquote><p>傀儡进程</p></blockquote><h4 id="Pre-check"><a href="#Pre-check" class="headerlink" title="Pre_check"></a>Pre_check</h4><p>这题居然让我电脑报毒了，让我康康！（康不懂，爬了</p><p>main函数很混乱，但仔细看能看出一点东西，貌似是创建一个进程，尝试把另一个文件读进来，然后开始执行？还看见一个熟悉的SMC</p><p>看了hint之后搜到了傀儡进程，一个最基本傀儡进程的实现如下</p><ul><li>CreateProcess创建进程，传入参数CREATE_SUSPENDED使进程挂起</li><li>NtUnmapViewOfSection清空新进程的内存数据</li><li>VirtualAllocEx申请新的内存</li><li>WriteProcessMemory向内存写入payload</li><li>SetThreadContext设置入口点</li><li>ResumeThread唤醒进程，执行payload</li></ul><h4 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h4><p>emmm直接调的话，由于各种奇怪的反调试，好像没法成功，于是我打开了010editor，直接把傀儡进程在运行前全都异或回去，并dump出来单独分析</p><p>清晰的main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main_0</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> input_len; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+0h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [esp+0h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">char</span> input[<span class="number">56</span>]; <span class="comment">// [esp+D0h] [ebp-3Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_40C015);</span><br><span class="line">  <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0x32</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input your flag: &quot;</span>, v5);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="keyword">char</span>)input);</span><br><span class="line">  input_len = <span class="built_in">strlen</span>(input);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)off_40A040(input, input_len) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulation~~~&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Try again~~~&quot;</span>, v6);</span><br><span class="line">  getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>off_40A040</code>一路往下点，就看到加密逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> __cdecl <span class="title">sub_4014F0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+DCh] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_40C015);</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">char</span>)(((*(_BYTE *)(i + a1) ^ <span class="number">0x66</span>) + <span class="number">4</span>) ^ <span class="number">0x55</span>) != byte_40A020[i] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺常规的，直接还原？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic_1 = [<span class="number">0x5A</span>,<span class="number">0x46</span>,<span class="number">0x59</span>,<span class="number">0x46</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x74</span>,<span class="number">0x63</span>,<span class="number">0x47</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x43</span>,<span class="number">0x47</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x5E</span>,<span class="number">0x44</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_1)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(((magic_1[i] ^ <span class="number">0x55</span>) -<span class="number">4</span>) ^ <span class="number">0x66</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># miniLctf&#123;Th1s_1s_th4_fak4_f1ag!&#125;</span></span><br></pre></td></tr></table></figure><p>我aklsjdaiwjdawijdaiwdjqw（</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><p>又是上一题一样的，在Exports里面有<code>TlsCallback_0_0</code></p><p>里面有对于<code>off_40A040</code>的指向进行处理，然后就没啥问题了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic_1 = [<span class="number">0x5A</span>,<span class="number">0x46</span>,<span class="number">0x59</span>,<span class="number">0x46</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x74</span>,<span class="number">0x63</span>,<span class="number">0x47</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x43</span>,<span class="number">0x47</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x5E</span>,<span class="number">0x44</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">fake_flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_1)):</span><br><span class="line">    fake_flag += <span class="built_in">chr</span>(((magic_1[i] ^ <span class="number">0x55</span>) -<span class="number">4</span>) ^ <span class="number">0x66</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_flag)</span><br><span class="line"></span><br><span class="line">magic_2=[<span class="number">0x5A</span>,<span class="number">0x26</span>,<span class="number">0x59</span>,<span class="number">0x26</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x54</span>,<span class="number">0x6D</span>,<span class="number">0x52</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x4C</span>,<span class="number">0x0F</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x43</span>,<span class="number">0x03</span>,<span class="number">0x4D</span>,<span class="number">0x03</span>,<span class="number">0x4C</span>,<span class="number">0x43</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_2)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(((magic_2[i] ^ <span class="number">0x66</span>) - <span class="number">4</span>) ^ <span class="number">0x55</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1><p>还是太菜了，虽然是校内rk3，但这分数太惨了，加油加油！</p>]]></content>
      
      
      <categories>
          
          <category> CTF-Competition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-01】NPUCTF2020-BabyObfuscation</title>
      <link href="2021/04/21/eec6d01d64db/"/>
      <url>2021/04/21/eec6d01d64db/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-1-查壳"><a href="#Step-1-查壳" class="headerlink" title="Step 1: 查壳"></a>Step 1: 查壳</h1><ol><li>发现是64位程序，无壳</li><li>运行程序提示为”WHERE IS MY KEY!?”</li></ol><h1 id="Step-2-IDA加载初步判断功能"><a href="#Step-2-IDA加载初步判断功能" class="headerlink" title="Step 2: IDA加载初步判断功能"></a>Step 2: IDA加载初步判断功能</h1><p><code>main</code>函数直接F5看的话，是这样一坨浆糊</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">bool</span> v18; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v22; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v26; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v28[<span class="number">68</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> Str[<span class="number">1008</span>]; <span class="comment">// [rsp+130h] [rbp+B0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v30[<span class="number">1008</span>]; <span class="comment">// [rsp+520h] [rbp+4A0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v31[<span class="number">4</span>]; <span class="comment">// [rsp+14E0h] [rbp+1460h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+14F0h] [rbp+1470h]</span></span><br><span class="line">  <span class="keyword">int</span> k; <span class="comment">// [rsp+14F4h] [rbp+1474h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+14F8h] [rbp+1478h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14FCh] [rbp+147Ch]</span></span><br><span class="line"></span><br><span class="line">  _main(argc, argv, envp);</span><br><span class="line">  <span class="built_in">memset</span>(v30, <span class="number">0</span>, <span class="number">0xFA0</span>ui64);</span><br><span class="line">  v30[<span class="number">1000</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v28, <span class="number">0</span>, <span class="number">0x100</span>ui64);</span><br><span class="line">  v28[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">64</span>; ++i )</span><br><span class="line">    v28[i] = i + <span class="number">1</span>;</span><br><span class="line">  v31[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  v31[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">  v31[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">  v31[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">  v30[<span class="number">1004</span>] = <span class="number">2</span>;</span><br><span class="line">  v30[<span class="number">1005</span>] = <span class="number">3</span>;</span><br><span class="line">  v30[<span class="number">1006</span>] = <span class="number">4</span>;</span><br><span class="line">  v30[<span class="number">1007</span>] = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;WHERE IS MY KEY!?&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%32s&quot;</span>, Str);</span><br><span class="line">  v32 = <span class="built_in">strlen</span>(Str);</span><br><span class="line">  v3 = F0X1(v28[j], v28[j]);</span><br><span class="line">  <span class="keyword">for</span> ( j = v3 / v28[j]; j &lt;= v32; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (v28[j] + v28[j + <span class="number">1</span>]) * (v28[j] + v28[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt;= (<span class="keyword">int</span>)(F0X5(<span class="number">2</span>, <span class="number">2</span>) * v28[j] * v28[j + <span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = ~Str[(<span class="keyword">int</span>)F0X4(j, <span class="number">1</span>)];</span><br><span class="line">      v6 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] = ~(v5 + v31[v6 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = F0X1(v28[j], v28[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; (<span class="keyword">int</span>)F0X1(v28[j + <span class="number">1</span>], ~(~v28[j + <span class="number">1</span>] + v28[j])) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v30[j];</span><br><span class="line">      v9 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] = ~(~v8 + v28[v9 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]) * v8;</span><br><span class="line">    &#125;</span><br><span class="line">    v10 = v28[j + <span class="number">1</span>];</span><br><span class="line">    v11 = F0X5(<span class="number">2</span>, <span class="number">1</span>) * v10;</span><br><span class="line">    v12 = v28[j];</span><br><span class="line">    v13 = F0X5(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    v14 = F0X1(v12 * v13, v11);</span><br><span class="line">    v15 = F0X5(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v14 == v15 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X1(v28[j], v28[j + <span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] ^= v31[v16 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = F0X5(V0X3, v28[j]);</span><br><span class="line">    v18 = v17 &lt; v28[j] + <span class="number">1</span>;</span><br><span class="line">    v19 = F0X5(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)F0X3(v19 &gt;= j, v18) )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = ~Str[(<span class="keyword">int</span>)F0X4(j, <span class="number">1</span>)];</span><br><span class="line">      v21 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] ^= ~(v20 + v31[v21 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    v22 = F0X5(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    v23 = F0X1(v28[j], v28[j]);</span><br><span class="line">    v30[j] *= v22 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X5(<span class="number">2</span>, v23 / v28[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  v24 = F0X5(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X4(v24, <span class="number">1</span>) != v32 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  v25 = F0X1(v28[k], v28[k]);</span><br><span class="line">  <span class="keyword">for</span> ( k = v25 / v28[k]; k &lt;= v32; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    v26 = v30[k];</span><br><span class="line">    <span class="keyword">if</span> ( v26 == (<span class="keyword">int</span>)F0X4(A0X6[k], <span class="number">1</span>) / <span class="number">10</span> )</span><br><span class="line">      ++V0X2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( V0X2 == v32 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nPASS&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_23:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nDENIED&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看<code>F0X1</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">    result = F0X1(a2, (<span class="keyword">int</span>)a1 % a2);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = a1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个递归函数容易发现是在求a1和a2的最大公因数gcd</p><p>然后是<code>F0X5</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X5</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (a2 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      v4 *= a1;</span><br><span class="line">    a1 *= a1;</span><br><span class="line">    a2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也比较容易看出来，就是在求a1的a2次方pow</p><p>接着是<code>F0X4</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X4</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)~(~a1 + a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于两个int而言，这个结构等价于a1-a2</p><p>继续看<code>F0X3</code>和<code>F0X2</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall F0X3(bool a1, bool a2)</span><br><span class="line">&#123;</span><br><span class="line">  char v2; &#x2F;&#x2F; bl</span><br><span class="line">  char v3; &#x2F;&#x2F; al</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; F0X2(a2, a2);</span><br><span class="line">  v3 &#x3D; F0X2(a1, a1);</span><br><span class="line">  return F0X2(v3, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_BOOL8 __fastcall F0X2(char a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  return a1 &#x3D;&#x3D; a2 &amp;&amp; a1 !&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个需要稍微推导一下，可以看出等价于a1&amp;a2</p><blockquote><p>对于函数的功能，可以考虑复制下来，然后测试一下，再结合推导，就能比较容易的判断出函数的功能了</p></blockquote><p>于是进行重命名</p><p><img src="https://i.loli.net/2021/04/21/lneU2O8a6YhrpVC.png" alt="p1.png"></p><h1 id="Step-3-判断条件跳转"><a href="#Step-3-判断条件跳转" class="headerlink" title="Step 3: 判断条件跳转"></a>Step 3: 判断条件跳转</h1><ul><li><p>第一处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v4 = (v28[j] + v28[j + <span class="number">1</span>]) * (v28[j] + v28[j + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ( v4 &gt;= (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2</span>) * v28[j] * v28[j + <span class="number">1</span>]) )</span><br></pre></td></tr></table></figure><p>抽象出来即</p><script type="math/tex; mode=display">(x + y) ^ 2 \ge 4xy</script><p>这是永真的，也就是下面的代码块永远会被执行</p></li><li><p>第二处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v7 = gcd(v28[j], v28[j + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ( v7 &gt; (<span class="keyword">int</span>)gcd(v28[j + <span class="number">1</span>], ~(~v28[j + <span class="number">1</span>] + v28[j])) )</span><br></pre></td></tr></table></figure><p>等价于</p><script type="math/tex; mode=display">gcd(x, y) > gcd(y, x-y)</script><p>左右两边显然是一样的，所以下面的代码块不可能执行</p></li><li><p>第三处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v10 = v28[j + <span class="number">1</span>];</span><br><span class="line">v11 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>) * v10;</span><br><span class="line">v12 = v28[j];</span><br><span class="line">v13 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">v14 = gcd(v12 * v13, v11);</span><br><span class="line">v15 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ( v14 == v15 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)gcd(v28[j], v28[j + <span class="number">1</span>]) )</span><br></pre></td></tr></table></figure><p>等价于</p><script type="math/tex; mode=display">gcd(2x, 2y) = 2gcd(x, y)</script><p>这也是永真的，故下面的代码块一定执行</p></li><li><p>第四处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v17 = <span class="built_in">pow</span>(V0X3, v28[j]);</span><br><span class="line">v18 = v17 &lt; v28[j] + <span class="number">1</span>;</span><br><span class="line">v19 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)AND(v19 &gt;= j, v18) )</span><br><span class="line"><span class="comment">//其中V0X3 == 3</span></span><br><span class="line"><span class="comment">//这里需要看看后面关于整个key长度的判断，这里就不说明了</span></span><br></pre></td></tr></table></figure><p>key长度是15故<code>v19 &gt;= j</code>必定成立</p><p>于是只需判断</p><script type="math/tex; mode=display">f(x)=3^x - x - 1 <0</script><p>求导或者直接画图都能判断出该条件为假，则下面的代码块不会执行</p></li><li><p><strong>综上</strong></p><p>只有三处代码有效</p><p><img src="https://i.loli.net/2021/04/21/i19yFkjOEmha56R.png" alt="p2.png"></p></li></ul><p>最终是这样的效果</p><h1 id="Step-4-exp"><a href="#Step-4-exp" class="headerlink" title="Step 4: exp"></a>Step 4: exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enc = [<span class="number">780</span>, <span class="number">780</span>, <span class="number">850</span>, <span class="number">590</span>, <span class="number">800</span>, <span class="number">640</span>, <span class="number">1150</span>, <span class="number">460</span>, <span class="number">980</span>, <span class="number">960</span>, <span class="number">1170</span>, <span class="number">530</span>, <span class="number">970</span>, <span class="number">1080</span>, <span class="number">1250</span>]</span><br><span class="line">vec = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i] = enc[i] // <span class="number">10</span>;</span><br><span class="line">    enc[i] ^= vec[i%<span class="number">4</span>]</span><br><span class="line">    enc[i] += vec[i%<span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc[i]), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1>]]></content>
      
      
      <categories>
          
          <category> CTF-Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
            <tag> BUUOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>whoami</title>
      <link href="2021/04/14/2390e06bacb2/"/>
      <url>2021/04/14/2390e06bacb2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">track</span><br></pre></td></tr></table></figure><p>来自XDSEC的大一逆向工程菜鸡</p><p>正努力追赶带佬们的脚步</p>]]></content>
      
      
      
        <tags>
            
            <tag> 简介 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
