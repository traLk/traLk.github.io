<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【WP-05】CTFSHOW逆向区题解</title>
      <link href="2021/06/26/d6d9887de546/"/>
      <url>2021/06/26/d6d9887de546/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF-Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Reverse </tag>
            
            <tag> WP </tag>
            
            <tag> CTFSHOW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-04】starCTF2021-wherekey</title>
      <link href="2021/06/13/00e0307e7cd0/"/>
      <url>2021/06/13/00e0307e7cd0/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-One"><a href="#Step-One" class="headerlink" title="Step One"></a>Step One</h1><ul><li>ELF64位程序，无壳，无符号表</li><li>运行提示输入key，随便输点东西，直接退出</li></ul><h1 id="Step-Two"><a href="#Step-Two" class="headerlink" title="Step Two"></a>Step Two</h1><p>拖进IDA找start函数，第一个参数就是main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// positive sp value has been detected, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">start</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp-8h] [rbp-8h] BYREF</span></span><br><span class="line">  <span class="keyword">void</span> *retaddr; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v4 = v5;</span><br><span class="line">  v5 = v3;</span><br><span class="line">  sub_402B60(</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">int</span>)main,</span><br><span class="line">    v4,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;retaddr,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_4037C0,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_403860,</span><br><span class="line">    a3,</span><br><span class="line">    (__int64)&amp;v5);</span><br><span class="line">  __halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对main函数中的函数名和变量进行重命名，通过它们调用的一些系统调用可以做到这一点，我没处理完，不过大概长这样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v7; <span class="comment">// rcx</span></span><br><span class="line">  u32 *v8; <span class="comment">// r8</span></span><br><span class="line">  u32 v9; <span class="comment">// er9</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 v11; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rcx</span></span><br><span class="line">  u32 *v13; <span class="comment">// r8</span></span><br><span class="line">  u32 v14; <span class="comment">// er9</span></span><br><span class="line">  fd_set v15; <span class="comment">// [rsp+10h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v16; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v16 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  socket = sub_40245B();</span><br><span class="line">  sockfd = sub_4024EB();</span><br><span class="line">  dword_4C8570 = sub_40257B(*(__int64 *)&amp;argc, (__int64)argv, v3);</span><br><span class="line">  <span class="built_in">printf</span>((__int64)<span class="string">&quot;Please enter the key:&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;v15, <span class="number">0</span>, <span class="keyword">sizeof</span>(v15));</span><br><span class="line">    v15.fds_bits[dword_4C8570 / <span class="number">64</span>] |= <span class="number">1LL</span> &lt;&lt; (dword_4C8570 % <span class="number">64</span>);</span><br><span class="line">    v15.fds_bits[sockfd / <span class="number">64</span>] |= <span class="number">1LL</span> &lt;&lt; (sockfd % <span class="number">64</span>);</span><br><span class="line">    sub_44E080(<span class="number">1024</span>, &amp;v15, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (v15.fds_bits[sockfd / <span class="number">64</span>] &amp; (<span class="number">1LL</span> &lt;&lt; (sockfd % <span class="number">64</span>))) != <span class="number">0</span> )</span><br><span class="line">      sub_40223C();                             <span class="comment">// here</span></span><br><span class="line">    v4 = v15.fds_bits[dword_4C8570 / <span class="number">64</span>];</span><br><span class="line">    <span class="keyword">if</span> ( (v4 &amp; (<span class="number">1LL</span> &lt;&lt; (dword_4C8570 % <span class="number">64</span>))) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ((<span class="keyword">void</span> (__fastcall *)(__int64))((<span class="keyword">char</span> *)&amp;sub_401D44 + <span class="number">1</span>))((__int64)&amp;unk_4C5120);</span><br><span class="line">      sub_411D40(v5, v4, v6, v7, v8, v9);</span><br><span class="line">      sub_402072();</span><br><span class="line">      ((<span class="keyword">void</span> (__fastcall *)(__int64))((<span class="keyword">char</span> *)&amp;sub_401D44 + <span class="number">1</span>))((__int64)&amp;unk_4C5130);</span><br><span class="line">      sub_411D40(v10, v4, v11, v12, v13, v14);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易找到<code>sub_40223C</code>，再同样进行重命名如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_40223C</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v1; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er8</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// er9</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">socklen_t</span> fromlen; <span class="comment">// [rsp+8h] [rbp-18h] OVERLAPPED BYREF</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> isRecv_4; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v10; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  isRecv_4 = <span class="number">0</span>;</span><br><span class="line">  fromlen = <span class="number">16</span>;</span><br><span class="line">  buf = (<span class="keyword">void</span> *)<span class="built_in">malloc</span>(<span class="number">10LL</span>);</span><br><span class="line">  sub_401120();</span><br><span class="line">  v0 = (__int64)buf;</span><br><span class="line">  v1 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sockfd;</span><br><span class="line">  isRecv_4 = recvfrom(sockfd, buf, <span class="number">5uLL</span>, <span class="number">0</span>, &amp;from, &amp;fromlen);</span><br><span class="line">  <span class="keyword">if</span> ( isRecv_4 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = (__int64)buf;</span><br><span class="line">    sub_4022DE((<span class="keyword">char</span> *)buf);                    <span class="comment">// here</span></span><br><span class="line">  &#125;</span><br><span class="line">  result = __readfsqword(<span class="number">0x28</span>u) ^ v10;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    sub_450C80(v1, v0, v2, v3, v4, v5);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，结合hint，猜测是用户通过tty输入内容，并通过socket发送至本地，再判断对错</p><p>容易发现<code>sub_4022DE</code>是接收到输入后的下一步操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">sub_4022DE</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v3; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r8</span></span><br><span class="line">  __int64 v5; <span class="comment">// r9</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> v10[<span class="number">5</span>]; <span class="comment">// [rsp+23h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v11; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !inp )</span><br><span class="line">    inp = <span class="built_in">malloc</span>(<span class="number">30LL</span>);</span><br><span class="line">  sub_401090();</span><br><span class="line">  v2 = (<span class="keyword">char</span> *)inp;</span><br><span class="line">  v9 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_401190();</span><br><span class="line">  v6 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cnt;</span><br><span class="line">  <span class="keyword">if</span> ( v9 &gt;= <span class="number">5</span> * cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      nullsub_3();</span><br><span class="line">      LayerOne((__int64)v10, i);</span><br><span class="line">      a1 = v10;</span><br><span class="line">      v2 = (<span class="keyword">char</span> *)(<span class="number">5</span> * cnt + inp);</span><br><span class="line">      v3 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">int</span>)LayerTwo(v2, v10, <span class="number">5</span>) % <span class="number">257</span>);</span><br><span class="line">      v6 = (__int64)res;</span><br><span class="line">      res[<span class="number">5</span> * cnt + i] = v3;</span><br><span class="line">    &#125;</span><br><span class="line">    ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( cnt &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> proc_then();</span><br><span class="line">  result = __readfsqword(<span class="number">0x28</span>u) ^ v11;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    sub_450C80((__int64)v2, (__int64)a1, v6, v3, v4, v5);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：这里有一个mod257，待会儿反解的时候是需要考虑到的</strong></p><p>俩加密函数内容如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">LayerOne</span><span class="params">(__int64 a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> counter; <span class="comment">// [rsp+18h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( a2 &lt;= <span class="number">24</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = counter++;</span><br><span class="line">    *(_BYTE *)(a1 + v2) = aFlagAreYouSure[a2];</span><br><span class="line">    a2 += <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nullsub_2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个是把fake flag分成五组，取每一组的第一个字符，放在a1中</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a3 = 5</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">LayerTwo</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">char</span> *a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+20h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a3; ++i )</span><br><span class="line">    v4 += a1[i] * a2[i];</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>把两个数组的对应位置相乘再相加</p></blockquote><p>结合前面<code>flag</code>是一列一列取，而<code>inp</code>是一行一行取，还有一个<code>LayerTwo</code>是相乘，容易想到这就是一个矩阵乘法。有了这个认知后，跟进<code>proc_then</code>进行查看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">proc_then</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbp</span></span><br><span class="line">  __int64 aim; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r8</span></span><br><span class="line">  __int64 v5; <span class="comment">// r9</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  aim = (__int64)&amp;unk_4C5150;</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_4010F0() )</span><br><span class="line">  &#123;</span><br><span class="line">    aim = <span class="number">3LL</span>;</span><br><span class="line">    sub_40FF90(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = __readfsqword(<span class="number">0x28</span>u) ^ *(_QWORD *)(v0 - <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    sub_450C80(aim, (__int64)res, v2, v3, v4, v5);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现<code>aim</code>是乘完的结果，跟进<code>sub_40FF90</code>，发现他是<code>syscall</code>函数，结合系统调用号3，这里应该是close掉socket连接</p><p><del>然后后面就不想分析了</del></p><h1 id="Step-Three"><a href="#Step-Three" class="headerlink" title="Step Three"></a>Step Three</h1><p>写一下解密脚本，需要一点线性代数知识</p><script type="math/tex; mode=display">AB=X\\\rarr A=XB^{-1}\\其中A代表输入，因为取的是行\\B代表fake\quad flag生成的矩阵，因为取的是列\\而X就是加密后的结果了</script><p>使用sage求解（用<code>numpy</code>、<code>matlab</code>都可以。<del>甚至手算也可以</del>）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sage: x &#x3D; Matrix(GF(257), [[0x38,0x6D,0x4B,0x4B,0xB9],</span><br><span class="line">....:                      [0x8A,0xF9,0x8A,0xBB,0x5C],</span><br><span class="line">....:                      [0x8A,0x9A,0xBA,0x6B,0xD2],</span><br><span class="line">....:                      [0xC6,0xBB,0x05,0x90,0x56],</span><br><span class="line">....:                      [0x93,0xE6,0x12,0xBD,0x4F]])</span><br><span class="line">sage: b &#x3D; Matrix(GF(257), [[102, 108, 97,  103, 123],</span><br><span class="line">....: ....:                [97, 114, 101, 95,  121],</span><br><span class="line">....: ....:                [111, 117, 95,  115, 117],</span><br><span class="line">....: ....:                [114, 101, 95,  102, 114],</span><br><span class="line">....: ....:                [105, 101, 110, 100, 125]])</span><br><span class="line">sage: flag &#x3D; x*b.inverse()</span><br><span class="line"></span><br><span class="line">sage: for i in flag:</span><br><span class="line">....:     for j in i:</span><br><span class="line">....:         print(chr(j))</span><br><span class="line">....:         </span><br><span class="line">H</span><br><span class="line">a</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">_</span><br><span class="line">f</span><br><span class="line">0</span><br><span class="line">n</span><br><span class="line">_</span><br><span class="line">9</span><br><span class="line">n</span><br><span class="line">d</span><br><span class="line">_</span><br><span class="line">G</span><br><span class="line">0</span><br><span class="line">o</span><br><span class="line">d</span><br><span class="line">-</span><br><span class="line">1</span><br><span class="line">u</span><br><span class="line">c</span><br><span class="line">k</span><br><span class="line">-</span><br><span class="line">O</span><br><span class="line">H</span><br></pre></td></tr></table></figure><p>得到<code>flag&#123;Ha23_f0n_9nd_G0od_luck_OH&#125;</code></p><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1>]]></content>
      
      
      <categories>
          
          <category> CTF-Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Reverse </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOTES-04】Go Tour</title>
      <link href="2021/06/10/84c9748611d2/"/>
      <url>2021/06/10/84c9748611d2/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Syntax"><a href="#Basic-Syntax" class="headerlink" title="Basic Syntax"></a>Basic Syntax</h2><p>关于为什么声明变量时要和C有所区别，参见这篇文章<a href="https://blog.go-zh.org/gos-declaration-syntax">Go’s Declaration Syntax</a></p><h2 id="Basic-Type"><a href="#Basic-Type" class="headerlink" title="Basic Type"></a>Basic Type</h2><p>Go 的基本类型有</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">    <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p><h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p><p>零值是：</p><ul><li>数值类型为 <code>0</code>，</li><li>布尔类型为 <code>false</code>，</li><li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li></ul><h2 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h2><p>一个在全局声明的数值常量由上下文决定其类型</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;rxyyds&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p><p>该语句声明的变量作用域仅在 <code>if</code> 之内。</p><p><strong>但是</strong>，在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。</p><p><strong>除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。</strong></p><p>Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。（这一个特性非常关键，使得switch的使用频率会大大增加）</p><p>没有条件的 switch 同 <code>switch true</code> 一样。（就类似于<code>for</code>不写条件得到一个无限循环）</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><p>defer 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><h3 id="defer栈"><a href="#defer栈" class="headerlink" title="defer栈"></a>defer栈</h3><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">counting</span><br><span class="line">done</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="defer-panic-and-recover"><a href="#defer-panic-and-recover" class="headerlink" title="defer-panic-and-recover"></a>defer-panic-and-recover</h3><p>看看这个吧！<a href="https://blog.go-zh.org/defer-panic-and-recover">defer-panic-recover</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered in f&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Calling g.&quot;</span>)</span><br><span class="line">    g(<span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from g.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Panicking!&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer in g&quot;</span>, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Printing in g&quot;</span>, i)</span><br><span class="line">    g(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Calling g.</span><br><span class="line">Printing in g 0</span><br><span class="line">Printing in g 1</span><br><span class="line">Printing in g 2</span><br><span class="line">Printing in g 3</span><br><span class="line">Panicking!</span><br><span class="line">Defer in g 3</span><br><span class="line">Defer in g 2</span><br><span class="line">Defer in g 1</span><br><span class="line">Defer in g 0</span><br><span class="line">panic: 4</span><br><span class="line"> </span><br><span class="line">panic PC&#x3D;0x2a9cd8</span><br><span class="line">[stack trace omitted]</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go 拥有指针。指针保存了值的内存地址。</p><p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。<strong>其零值为 <code>nil</code>。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p *int</span><br></pre></td></tr></table></figure><p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i :&#x3D; 42</span><br><span class="line">p &#x3D; &amp;i</span><br></pre></td></tr></table></figure><p><code>*</code> 操作符表示指针指向的底层值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(*p) &#x2F;&#x2F; 通过指针 p 读取 i</span><br><span class="line">*p &#x3D; 21         &#x2F;&#x2F; 通过指针 p 设置 i</span><br></pre></td></tr></table></figure><p>这也就是通常所说的“间接引用”或“重定向”。</p><p><strong>与 C 不同，Go 没有指针运算。</strong></p><p>例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">p := &amp;i         <span class="comment">// 指向 i</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 通过指针读取 i 的值</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针设置 i 的值</span></span><br><span class="line">fmt.Println(i)  <span class="comment">// 查看 i 的值</span></span><br><span class="line"></span><br><span class="line">p = &amp;j         <span class="comment">// 指向 j</span></span><br><span class="line">*p = *p / <span class="number">37</span>   <span class="comment">// 通过指针对 j 进行除法运算</span></span><br><span class="line">fmt.Println(j) <span class="comment">// 查看 j 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">42</span><br><span class="line">21</span><br><span class="line">73</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>用一个例子来说明</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;) <span class="comment">// 大括号来初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体字段可以通过<strong>点号</strong>来访问，也可以通过<strong>结构体指针</strong>来访问。</p><p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用<strong>隐式间接</strong>引用，直接写 <code>p.X</code> 就可以。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>Goroutine是一个协程，它与所处的函数是分开运行的，并且具有背后运行机制。即如果它所处的函数已经结束运行，不管还有多少Goroutine没有结束，都会被终止运行</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">count(<span class="number">5</span>, <span class="string">&quot;ysh&quot;</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">count(<span class="number">3</span>, <span class="string">&quot;bobo&quot;</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(n <span class="keyword">int</span>, baby <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">fmt.Println(i+<span class="number">1</span>, baby)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><h4 id="一般语言——内存共享来交流"><a href="#一般语言——内存共享来交流" class="headerlink" title="一般语言——内存共享来交流"></a>一般语言——内存共享来交流</h4><p>通常一个具有多线程能力的编程语言都需要线程之间进行交流，而一般是通过共享内存来交流，即各个线程共同操纵同一片内存区域，并且开发者为了避免同时操纵内存造成的错误，还发明了线程锁，包括最简单的自旋锁。</p><h4 id="Golang——交流来共享内存"><a href="#Golang——交流来共享内存" class="headerlink" title="Golang——交流来共享内存"></a>Golang——交流来共享内存</h4><p>go语言并不是这么操作的，它是通过线程间的一个channel来交流，（可以简单把它理解为自带的一个锁），这就表现为：</p><p><strong>发送一条消息，代码被阻塞，直到有人收听；收听一条消息，代码被阻塞，直到有人发送</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> count(<span class="number">5</span>, <span class="string">&quot;hs&quot;</span>, c)</span><br><span class="line">    <span class="keyword">for</span> message := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(n <span class="keyword">int</span>, animal <span class="keyword">string</span>, c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- animal</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于range可以查看这个：<a href="https://github.com/golang/go/wiki/Range">range</a></p><h4 id="如何管理多个channel？"><a href="#如何管理多个channel？" class="headerlink" title="如何管理多个channel？"></a>如何管理多个channel？</h4><p>首先说一下为什么要涉及这个问题，你可能会觉得我难道不能写一个循环，先接收一条消息，再接收一条消息吗？确实，你确实可以，但这么做的代价也很容易想到——<strong>因为channel的阻塞特性，如果两个线程的运行时间相差非常大的话，就会造成非常严重的时间损耗</strong></p><p>我们可以使用select语句，它会在我们提前给定好的channel中选择没有被阻塞的来运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c1 :&#x3D; make(chan string)</span><br><span class="line">c2 :&#x3D; make(chan string)</span><br><span class="line">go func() &#123;</span><br><span class="line">c1 &lt;- &quot;hs&quot;</span><br><span class="line">time.Sleep(time.Millisecond * 500)</span><br><span class="line">&#125;()</span><br><span class="line">go func() &#123;</span><br><span class="line">c2 &lt;- &quot;dbt&quot;</span><br><span class="line">time.Sleep(time.Millisecond * 2000)</span><br><span class="line">&#125;()</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case msg :&#x3D; &lt;- c1:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">case msg :&#x3D; &lt;- c2:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的正确使用姿势"><a href="#map的正确使用姿势" class="headerlink" title="map的正确使用姿势"></a>map的正确使用姿势</h2><p>直接查看<a href="https://www.jianshu.com/p/726688f6539c">map</a></p><h2 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h2><p>参考<a href="https://www.jianshu.com/p/f79aaf39ded8">sort</a></p><h2 id="slice切片"><a href="#slice切片" class="headerlink" title="slice切片"></a>slice切片</h2><p>参考<a href="https://www.jianshu.com/p/ca4891ad6e4f">slice</a></p><h3 id="切片就像数组的引用"><a href="#切片就像数组的引用" class="headerlink" title="切片就像数组的引用"></a>切片就像数组的引用</h3><p>切片并不存储任何数据，它只是描述了底层数组中的一段。</p><p>更改切片的元素会修改其底层数组中对应的元素。</p><p>与它共享底层数组的切片都会观测到这些修改。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">names := [<span class="number">4</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">&quot;John&quot;</span>,</span><br><span class="line"><span class="string">&quot;Paul&quot;</span>,</span><br><span class="line"><span class="string">&quot;George&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ringo&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(names)</span><br><span class="line"></span><br><span class="line">a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span></span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">fmt.Println(names)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">//[John Paul George Ringo]</span></span><br><span class="line"><span class="comment">//[John Paul] [Paul George]</span></span><br><span class="line"><span class="comment">//[John XXX] [XXX George]</span></span><br><span class="line"><span class="comment">//[John XXX George Ringo]</span></span><br></pre></td></tr></table></figure><h3 id="切片文法"><a href="#切片文法" class="headerlink" title="切片文法"></a>切片文法</h3><p>切片文法类似于没有长度的数组文法。</p><p>这是一个数组文法：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">q := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(q)</span><br><span class="line"></span><br><span class="line">r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的长度与容量"><a href="#切片的长度与容量" class="headerlink" title="切片的长度与容量"></a>切片的长度与容量</h3><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p><p>切片的长度就是它所包含的元素个数。</p><p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p><p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p><p>你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。</p><h3 id="nil-切片"><a href="#nil-切片" class="headerlink" title="nil 切片"></a>nil 切片</h3><p>切片的零值是 <code>nil</code>。</p><p>nil 切片的长度和容量为 0 且没有底层数组。</p><h3 id="用-make-创建切片"><a href="#用-make-创建切片" class="headerlink" title="用 make 创建切片"></a>用 make 创建切片</h3><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br></pre></td></tr></table></figure><h3 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h3><p>切片可包含任何类型，甚至包括其它的切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个井字板（经典游戏）</span></span><br><span class="line">board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个玩家轮流打上 X 和 O</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, strings.Join(board[i], <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向切片追加元素"><a href="#向切片追加元素" class="headerlink" title="向切片追加元素"></a>向切片追加元素</h3><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数。内建函数的<a href="https://go-zh.org/pkg/builtin/#append">文档</a>对此函数有详细的介绍。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure><p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p><p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p><p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个空切片</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个切片会按需增长</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.go-zh.org/go-slices-usage-and-internals">Go 切片：用法和本质</a></p><h2 id="range用法"><a href="#range用法" class="headerlink" title="range用法"></a>range用法</h2><p>参考<a href="https://github.com/golang/go/wiki/Range">range</a>以及<a href="https://studygolang.com/articles/12958">Golang中range的使用方法及注意事项</a></p><h2 id="unsafe-Pointer-VS-uintptr"><a href="#unsafe-Pointer-VS-uintptr" class="headerlink" title="unsafe.Pointer VS. uintptr"></a>unsafe.Pointer VS. uintptr</h2><blockquote><p>可以在go官网下载go的source，接着找到$GOROOT（现在没有这个环境变量了，它其实不应该有。可用命令go env命令得到）下src下的unsafe中的unsafe.go，然后开始你的学习</p></blockquote><h3 id="为什么要有这个包？"><a href="#为什么要有这个包？" class="headerlink" title="为什么要有这个包？"></a>为什么要有这个包？</h3><p>用它可以绕过Go程序内置的类型转换安全性检查，即unsafe 包会允许我们可以直接访问存储这个变量原始二进制信息的地址。在我们想绕过类型限制的时候可以使用它。</p><p>导入 unsafe 的包可能是不可移植( non-portable) 的，而且不受 Go 1 兼容性准则的保护。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgolang.org%2Fdoc%2Fgo1compat%23expectations">Go 1 的手册清楚地说明</a>，如果他们改变了实现方式，使用 unsafe 包可能会破坏你的代码。引入了 unsafe 的包可能依赖于 Go 实现的内部属性。我们保留修改实现方法的权利，这也许会破坏此类程序。我们需要记住的是，在 Go 1 中，内部实现可能会发生变化，并且我们也许会遇到类似 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fissues%2F16769">issues  this ticket in Github</a>   中所见的问题，两个 Go 版本之间的行为有略微的改变。不过， Go 的一些标准库中也在许多地方使用了 unsafe 包。</p><h3 id="这个包有什么？"><a href="#这个包有什么？" class="headerlink" title="这个包有什么？"></a>这个包有什么？</h3><p><code>type ArbitraryType int</code>：</p><p>它表示一个Go表达式中的任意类型，它是为了文档说明方便存在的。</p><p><code>type Pointer *ArbitraryType</code>：</p><p>表示一个指向任意类型的指针。</p><p><code>func Sizeof(x ArbitraryType) uintptr</code>：</p><p>接受一个任意类型的数据并返回它的字节数，类型为uintptr。<strong>注意：</strong>并且任何有关于x的引用都不会计算在内。</p><p><code>func Offsetof(x ArbitraryType) uintptr</code>：</p><p>它返回一个结构体中某一字段的偏移量。</p><p><code>func Alignof(x ArbitraryType) uintptr</code></p><h3 id="这个包怎么用？"><a href="#这个包怎么用？" class="headerlink" title="这个包怎么用？"></a>这个包怎么用？</h3><p>支持四种运算：</p><ul><li><p>任何类型的指针值都可以转换为Pointer。</p></li><li><p>Pointer可以转换为任何类型的指针值。</p></li><li><p>uintptr可以转换为Pointer。</p></li><li><p>可以将Pointer转换为uintptr。</p></li></ul><p>下面给出几种使用场景</p><ul><li><p>将 <em>T1 转换为指向 </em>T2 的指针<br>假设 T2 不大于 T1 并且两者共享一个等价的内存布局，这种转换允许将一种类型的数据重新解释为其他类型的数据。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">实现math.Float64bits:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64bits</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;f))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将指针转换为uintptr（但不返回指针）<br>将指针转换为uintptr会产生值的内存地址，并视作一个整数。这种uintptr的通常用途是打印它。</p></li><li><p>将uintptr转换回Pointer通常是无效的<br>uintptr 是一个整数，而不是一个引用。<br>将指针转换为 uintptr 会创建一个整数值，它没有指针语义。<br>即使 uintptr 持有某个对象的地址，垃圾收集器不会更新那个 uintptr 的值，如果对象移动，那么 uintptr 也不会保留对象。</p></li><li><p>使用算术将指针转换为uintptr并返回<br>如果p指向一个已分配的对象，则可以通过该对象进行索引，即通过转换为 uintptr，添加一个偏移量，然后转换回 Pointer。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + offset)</span><br></pre></td></tr></table></figure><p>这种模式最常见的用途是访问结构体中的字段<br>或数组的元素：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := unsafe.Pointer(&amp;s.f)</span><br><span class="line">f := unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := unsafe.Pointer(&amp;x[i])</span><br><span class="line">e := unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;x[<span class="number">0</span>])) + i*unsafe.Sizeof(x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p>以这种方式从指针中添加和减去偏移量都是有效的。<br>使用 &amp;^ 来舍入指针也是有效的，通常用于对齐。<br>在所有情况下，结果必须继续指向原始分配的对象。</p><p>与 C 不同，将指针移到刚好超出 C 的末尾是无效的</p><p>无效：已分配空间外的端点。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s thing</span><br><span class="line">end = unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))</span><br></pre></td></tr></table></figure><p>无效：已分配空间外的端点。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">end = unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="keyword">uintptr</span>(n))</span><br></pre></td></tr></table></figure><p><strong>无效：uintptr 不能存储在变量中</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">u := <span class="keyword">uintptr</span>(p)</span><br><span class="line">p = unsafe.Pointer(u + offset)</span><br></pre></td></tr></table></figure><p>注意指针必须指向一个已分配的对象，所以它可能不为nil。<br><strong>无效：nil 指针的转换</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">u := unsafe.Pointer(<span class="literal">nil</span>)</span><br><span class="line">p := unsafe.Pointer(<span class="keyword">uintptr</span>(u) + offset)</span><br></pre></td></tr></table></figure></li><li><p>调用syscall.Syscall时将指针转换为uintptr。<br>syscall 包中的 Syscall 函数直接传递它们的 uintptr 参数到操作系统，然后操作系统可能会根据调用的详细信息，将其中一些重新解释为指针。即系统调用实现隐式转换某些参数。<br>如果必须将指针参数转换为 uintptr 才能用作参数，<br>该转换必须出现在调用表达式本身中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syscall.Syscall(SYS_READ, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(unsafe.Pointer(p)), <span class="keyword">uintptr</span>(n))</span><br></pre></td></tr></table></figure><p>编译器处理在参数列表中转换为 uintptr 的指针，对在汇编中实现的函数的调用：通过安排引用的分配的对象，在调用完成之前被保留并且不会移动。</p></li><li><p>reflect.Value.Pointer或reflect.Value.UnsafeAddr的结果的转换</p><p>包反射的名为 Pointer 和 UnsafeAddr 的 Value 方法返回类型 uintptr而不是 unsafe.Pointer 以防止调用者将结果更改为任意值而没有引用unsafe包</p><p>然而，必须在调用后立即转换为指针</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := (*<span class="keyword">int</span>)(unsafe.Pointer(reflect.ValueOf(<span class="built_in">new</span>(<span class="keyword">int</span>)).Pointer()))</span><br></pre></td></tr></table></figure></li><li><p>将reflect.SliceHeader 或reflect.StringHeader Data 字段转换为Pointer 或从Pointer 转换。</p><p>和前面的例子一样，反射数据结构 SliceHeader 和 StringHeader将字段 Data 声明为 uintptr 以防止调用者将结果更改为任意类型而不先导入unsafe的。然而，这意味着SliceHeader 和 StringHeader 仅在解释内容时有效。</p><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">var s string</span></span><br><span class="line"><span class="xml">hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // case 1</span></span><br><span class="line"><span class="xml">hdr.Data = uintptr(unsafe.Pointer(p)) // case 6（本例）</span></span><br><span class="line"><span class="xml">hdr.Len = n</span></span><br></pre></td></tr></table></figure><p>在这种用法中，hdr.Data 实际上是引用底层字符串头中的指针的另一种方式，而不是 uintptr 变量本身。<br>一般来说，仅当 <em>reflect.SliceHeader 和 </em>reflect.StringHeader 指向实际切片或字符串（绝不是普通结构）时，我们去使用reflect.SliceHeader和reflect.StringHeader。<br>程序不应声明或分配这些结构类型的变量。</p><p><strong>无效：直接声明的标头不会将数据作为引用保存</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hdr reflect.StringHeader</span><br><span class="line">hdr.Data = <span class="keyword">uintptr</span>(unsafe.Pointer(p))</span><br><span class="line">hdr.Len = n</span><br><span class="line">s := *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;hdr)) <span class="comment">// p 可能已经丢失</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> Notes </tag>
            
            <tag> Golang </tag>
            
            <tag> Programs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOTES-03】StreamCipher-线性反馈移位寄存器</title>
      <link href="2021/05/22/1fbd3db05dc3/"/>
      <url>2021/05/22/1fbd3db05dc3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>接着上一篇往下，该写LFSR(linear feedback shift register)了</p></blockquote><h1 id="什么是线性反馈移位寄存器"><a href="#什么是线性反馈移位寄存器" class="headerlink" title="什么是线性反馈移位寄存器"></a>什么是线性反馈移位寄存器</h1><p>我先递归学习了几个数学概念</p><h2 id="母函数（生成函数）"><a href="#母函数（生成函数）" class="headerlink" title="母函数（生成函数）"></a>母函数（生成函数）</h2><h3 id="普通型母函数"><a href="#普通型母函数" class="headerlink" title="普通型母函数"></a>普通型母函数</h3><p><strong>定义</strong>：</p><p>对于任意一个数列$a_0,a_1,a_2\cdots a_n$，用它的每一项可以定义一个函数：</p><script type="math/tex; mode=display">G(x)=a_0+a_1x+a_2x^2+\cdots +a_nx^n</script><p>则G(x)是数列的生成函数，或者更准确地说，是一个<strong>无穷级数</strong></p><blockquote><p>虽然说是一个无穷级数，但我们可以设置$j&gt;n$时，$a_j=0$之类的，使得G(x)成为一个n次多项式，但又是一个无穷序列（doge</p></blockquote><p>更数学一点的表示形式如下：</p><script type="math/tex; mode=display">G(a_n;x)=\Sigma_{n=0}^\infty a_nx^n</script><h3 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h3><p>一般形式为：</p><script type="math/tex; mode=display">EG(a_n;x)=\Sigma_{n=0}^\infty a_n\frac{x^n}{n!}</script><h2 id="有限数域上的LFSR"><a href="#有限数域上的LFSR" class="headerlink" title="有限数域上的LFSR"></a>有限数域上的LFSR</h2><blockquote><p>有限数域一般是gf(2)，即只含有0, 1两个数</p></blockquote><h3 id="说明与定义"><a href="#说明与定义" class="headerlink" title="说明与定义"></a>说明与定义</h3><ul><li>移位寄存器主要功能是产生密钥流</li><li>gf(2)表示存储器为二元存储器，只能取0或1</li><li>n级表示n个存储器</li><li>线性表示反馈函数$f(a1,a2,…,an)$为线性函数,运算有与或非，与反馈移位寄存器的状态有关，状态有$2^n$种</li><li>初始状态由用户决定</li></ul><p><img src="https://ctf-wiki.org/crypto/streamcipher/fsr/figure/n-fsr.png" alt="n-fsr.png (934×244) (ctf-wiki.org)"></p><div align="center">图1</div><p><img src="https://img-blog.csdnimg.cn/20200717222000117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjczMzQ0Mg==,size_16,color_FFFFFF,t_70" alt="20200717222000117.png (1151×555) (csdnimg.cn)"></p><div align="center">图2</div><p>可作递推模拟如下：</p><script type="math/tex; mode=display">a_{n+t}=c_1a_{n+t-1}\bigoplus c_2a_{n+t-2}\bigoplus\cdots \bigoplus c_na_{t}, t=1,2,\cdots</script><p><strong>让我们看一个3级的例子</strong></p><p><img src="https://img-blog.csdnimg.cn/20200717223543874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjczMzQ0Mg==,size_16,color_FFFFFF,t_70" alt="20200717223543874.png (1226×421) (csdnimg.cn)"></p><p>定义初始状态为</p><div class="table-container"><table><thead><tr><th style="text-align:center">$a_1$</th><th style="text-align:center">$a_2$</th><th style="text-align:center">$a_3$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><p>则$a_4=a_1\bigoplus a_3=0$，然后流出一个$a_1$，3个寄存器变为</p><pre class="mermaid">graph LR    a4-->a3-->a2</pre><p>反馈函数变为$f(a_2,a_3,a_4)=a_2\bigoplus a_4$</p><p>反复进行几轮上述操作，就可以得到输出序列，以及周期</p><h3 id="LFSR输出序列的性质"><a href="#LFSR输出序列的性质" class="headerlink" title="LFSR输出序列的性质"></a>LFSR输出序列的性质</h3><p>线性反馈移位寄存器实现起来简单，速度快，而且有较为成功的理论，成为构造密钥流生成器的最重要的部件之一。<br>我们总是假定$c_1,c_2,…,c_n$中至少有一个不为0，否则$f(a1,a2,…,an)=0$，总是假定$c_n=1$。</p><ul><li>$n级LFSR状态数：最多有2^n个$</li><li>$n级LFSR的状态周期：\leq2^n-1$</li><li>$输出序列的周期=状态周期\leq2^n-1$</li><li>$选择合适的反馈函数可使序列的周期达到最大值2^n-1，周期达到最大值的序列称为m序列。$</li></ul><h3 id="数学推导与算法"><a href="#数学推导与算法" class="headerlink" title="数学推导与算法"></a>数学推导与算法</h3><blockquote><p>摘自<a href="https://ctf-wiki.org">CTFwiki</a></p></blockquote><p>线性反馈移位寄存器的反馈函数一般如下</p><script type="math/tex; mode=display">a_{i+n} = \Sigma_{j=1}^n c_ja_{i+n-j} \tag{1}</script><p>其中，$c_j$均在某个有限域 $F_q$ 中。</p><p>进而，可以求得其<strong>特征多项式</strong>为</p><script type="math/tex; mode=display">f(x)=x^n-\Sigma_{i=1}^n c_ix^{n-i} \tag{2}</script><blockquote><p>通过线性变换得到，由于还没学，就先随便写写啦hhh</p><script type="math/tex; mode=display">\left[\begin{matrix}a_{i+1},a_{i+2},a_{i+3},\cdots,a_{i+n}\end{matrix}\right] \\=\left[\begin{matrix}a_{i+1},a_{i+2},a_{i+3},\cdots,a_{i+n}\end{matrix}\right]\left[\begin{matrix}0 & 0 & \cdots & 0 & c_n\\1 & 0 & \cdots & 0 & c_{n-1}\\0 & 1 & \cdots & 0 & c_{n-2}\\\vdots& \vdots &\ddots&\vdots\\0 & 0 & \cdots & 1 & c_1\end{matrix}\right]\\=\left[\begin{matrix}a_{0},a_{1},a_{2},\cdots,a_{n-1}\end{matrix}\right]\left[\begin{matrix}0 & 0 & \cdots & 0 & c_n\\1 & 0 & \cdots & 0 & c_{n-1}\\0 & 1 & \cdots & 0 & c_{n-2}\\\vdots& \vdots &\ddots&\vdots\\0 & 0 & \cdots & 1 & c_1\end{matrix}\right]^{i+1}</script></blockquote><p>同时，定义其<strong>互反多项式</strong>为</p><script type="math/tex; mode=display">\bar f(x) = x^nf(\frac 1 x) = 1 - \Sigma_{i=1}^n c_ix^i</script><p>也称互反多项式为线性反馈移位寄存器的联结多项式。</p><h3 id="特征多项式与生成函数"><a href="#特征多项式与生成函数" class="headerlink" title="特征多项式与生成函数"></a>特征多项式与生成函数</h3><p>已知某个 n 级线性反馈移位寄存器的特征多项式，那么该序列对应的生成函数为</p><script type="math/tex; mode=display">A(x) = \frac {p(x)} {\bar f(x)}</script><p>其中$p(x) = \Sigma_{i=1}^n(c_{n-i}x^{n-i}\Sigma_{j=1}^ia_jx^{j-1})$。可以看出 $p(x) $完全由初始状态和反馈函数的系数决定。</p><h3 id="序列周期与生成函数"><a href="#序列周期与生成函数" class="headerlink" title="序列周期与生成函数"></a>序列周期与生成函数</h3><p>序列的的周期为其生成函数的既约真分式的分母的周期。</p><p>对于 n 级线性反馈移位寄存器，最长周期为 $2^n−1$（排除全零）。达到最长周期的序列一般称为 m 序列。</p><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>将两个序列累加得到新的序列的周期为这两个序列的周期的和。</li><li>序列是 n 级 m 序列，当且仅当序列的极小多项式是 n 次本原多项式。</li></ul><h3 id="B-M-算法"><a href="#B-M-算法" class="headerlink" title="B-M 算法"></a>B-M 算法</h3><p>一般来说，我们可以从两种角度来考虑 LFSR</p><ul><li>密钥生成角度，一般我们希望使用<strong>级数尽可能低</strong>的 LFSR 来生成周期大，随机性好的序列。</li><li>密码分析角度，给定一个长度为 n 的序列 a，如何<strong>构造一个级数尽可能小</strong>的 LFSR 来生成它。其实这就是 B-M 算法的来源。</li></ul><p>一般来说，我们定义一个序列的线性复杂度如下</p><ul><li>若 s 为一个全零序列，则线性复杂度为 0。</li><li>若没有 LFSR 能生成 s，则线性复杂度为无穷。</li><li>否则，s 的线性复杂度为生成 L(s) 的最小级的 LFSR。</li></ul><p>BM 算法的要求我们需要知道长度为 2n 的序列。其复杂度</p><ul><li>时间复杂度：$O(n^2)$ 次比特操作</li><li>空间复杂度：$O(n) $比特。</li></ul><p>关于 BM 算法的细节，后续添加，目前处于学习过程中。</p><p>但是其实如果我们知道了长度为 2n 的序列，我们也可以一种比较笨的方法来获取原先的序列。不妨假设已知的序列为$a_1,…,a_{2n}$，我们可以令</p><script type="math/tex; mode=display">S_1=(a_1,...,a_n)\\S_2=(a_2,...,a_{n+1})\\....\\S_{n+1}=(a_{n+1},...,a_{2n})</script><p>那么我们可以构造矩阵$ X=(S_1,…,S_n)$，那么</p><p>$S_{n+1}=(c_n,…,c_1)X$</p><p>所以$(c_n,…,c_1)=S_{n+1}X^{−1}$</p><p>进而我们也就知道了 LFSR 的反馈表达式，进而我们就可以推出初始化种子。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="2018-CISCN-初赛-oldstreamgame"><a href="#2018-CISCN-初赛-oldstreamgame" class="headerlink" title="2018 CISCN 初赛 oldstreamgame"></a>2018 CISCN 初赛 oldstreamgame</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&quot;flag&#123;xxxxxxxxxxxxxxxx&#125;&quot;</span></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">&quot;flag&#123;&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> flag.endswith(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag)==<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span>(<span class="params">R,mask</span>):</span></span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span> <span class="comment"># R&lt;&lt;1，取低32位，最后一位是0</span></span><br><span class="line">    i=(R&amp;mask)&amp;<span class="number">0xffffffff</span> <span class="comment"># R和mask与一下</span></span><br><span class="line">    lastbit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">        lastbit^=(i&amp;<span class="number">1</span>) <span class="comment"># i由最后一位逐位向最高位异或，存在lastbit中，lastbit只有1个bit</span></span><br><span class="line">        i=i&gt;&gt;<span class="number">1</span></span><br><span class="line">    output^=lastbit <span class="comment"># out的最后一位变成lastbit，其它不变</span></span><br><span class="line">    <span class="keyword">return</span> (output,lastbit)</span><br><span class="line"></span><br><span class="line">R=<span class="built_in">int</span>(flag[<span class="number">5</span>:-<span class="number">1</span>],<span class="number">16</span>) <span class="comment"># 长度为8*4=32bits，内容为16进制</span></span><br><span class="line">mask = <span class="number">0b10100100000010000000100010010100</span> <span class="comment"># 32bits</span></span><br><span class="line"></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    tmp=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        (R,out)=lfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; <span class="number">1</span>)^out</span><br><span class="line">    f.write(<span class="built_in">chr</span>(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>下面<strong>细看一下mask的性质</strong></p><ul><li><p>只有第3、5、8、12、20、27、30、32位是1，其它都是0，这就导致如果R的    对应位全不为1，那么i就为0</p></li><li><p>lastbit是由i逐位向前异或的，碰到0可以忽略，所以lastbit最后的值取决于i中1的个数，如果是奇数个1，则lastbit为1；否则lastbit为0。而i中1的奇偶数取决于R的3、5、8、12、20、27、30、32位。</p></li><li><p>于是可以得到线性反馈函数</p><script type="math/tex; mode=display">lastbit=R_3\bigoplus R_3\bigoplus R_5\bigoplus R_8\bigoplus R_{12}\bigoplus R_{20}\bigoplus R_{27}\bigoplus R_{30}\bigoplus R_{32}</script></li></ul><p>下面<strong>开始求解</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = <span class="string">&#x27;10100100000010000000100010010100&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;00100000111111011110111011111000&#x27;</span></span><br><span class="line">tmp = key</span><br><span class="line">R = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    output = <span class="string">&#x27;?&#x27;</span>+key[:<span class="number">31</span>]</span><br><span class="line">    ans= <span class="built_in">int</span>(tmp[-<span class="number">1</span>-i])^<span class="built_in">int</span>(output[-<span class="number">3</span>])^<span class="built_in">int</span>(output[-<span class="number">5</span>])^<span class="built_in">int</span>(output[-<span class="number">8</span>])^<span class="built_in">int</span>(output[-<span class="number">12</span>])^<span class="built_in">int</span>(output[-<span class="number">20</span>])^<span class="built_in">int</span>(output[-<span class="number">27</span>])^<span class="built_in">int</span>(output[-<span class="number">30</span>])</span><br><span class="line">    R += <span class="built_in">str</span>(ans)</span><br><span class="line">    key = <span class="built_in">str</span>(ans) + key[:<span class="number">31</span>]</span><br><span class="line"></span><br><span class="line">R = <span class="built_in">hex</span>(<span class="built_in">int</span>(R[::-<span class="number">1</span>], <span class="number">2</span>))[<span class="number">2</span>::]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag&#123;&#x27;</span>+R+<span class="string">&#x27;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF-Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Cryptography </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOTES-02】StreamCipher-线性同余生成器</title>
      <link href="2021/05/20/a3ad9f5d9c40/"/>
      <url>2021/05/20/a3ad9f5d9c40/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在学习流密码，看CTFWiki的过程中有一些疑问和理解，就记录下来方便之后查阅</p></blockquote><h1 id="Method-One"><a href="#Method-One" class="headerlink" title="Method One"></a>Method One</h1><p>程序的大概意思就是一个猜数游戏，如果连续猜中若干次，就算会拿到 flag，背后的生成相应数的核心代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># generate seed with 64 bits of entropy</span></span><br><span class="line">        self.p = <span class="number">4646704883L</span></span><br><span class="line">        self.x = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        self.y = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">        self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line">        <span class="keyword">return</span> (self.x ^ self.y)</span><br></pre></td></tr></table></figure><p>显然，我们猜出前两轮还是比较容易的，毕竟概率也有 0.25。这里当我们猜出前两轮后，使用 Z3 来求解出初始的 x 和 y，那么我们就可以顺利的猜出剩下的值了。不妨进行一波数学推导</p><p><strong>注：$\bigoplus$表示异或</strong></p><script type="math/tex; mode=display">p = 4646704883\\x_0 = random.randint(0, p)\\y_0 = random.randint(0, p)\\x_1 = (2x_0 + 3) \% p\\y_1 = (3y_0 + 9) \% p\\sol_1 = x_1 \bigoplus y_1\\x_2 = (2x_1 + 3) \% p = (2((2x_0 + 3) \% p) + 3) \% p\\y_2 = (3y_1 + 9) \% p = (3((3x_0 + 9) \% p) + 9) \% p\\sol_2 = x_2 \bigoplus y_2</script><p>思路大概就是，如果能猜到$sol_1$和$sol_2$，就能直接得到$x_0$和$y_0$，如此以来，就能算得所有的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">s1cor = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>]) <span class="comment"># 运行程序的时候直接附上猜得的两个值</span></span><br><span class="line">s2cor = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">dimVector =<span class="number">35</span> <span class="comment"># <span class="doctag">TODO:</span> 事实上p只有33bits，不知道这里为什么要设成35bits</span></span><br><span class="line">x = BitVec(<span class="string">&#x27;x&#x27;</span>, dimVector)</span><br><span class="line">y = BitVec(<span class="string">&#x27;y&#x27;</span>, dimVector)</span><br><span class="line">p = BitVec(<span class="string">&#x27;p&#x27;</span>,dimVector)</span><br><span class="line">s1 = BitVec(<span class="string">&#x27;s1&#x27;</span>,dimVector)</span><br><span class="line">s2 = BitVec(<span class="string">&#x27;s2&#x27;</span>,dimVector)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(p == <span class="number">4646704883L</span>)</span><br><span class="line">s.add(s1 == s1cor)</span><br><span class="line">s.add(s2== s2cor)</span><br><span class="line">s.add( ( ( ( <span class="number">2</span> * x + <span class="number">3</span> ) % p ) ^ ( ( <span class="number">3</span> * y + <span class="number">9</span> ) % p ) )==s1)</span><br><span class="line">s.add(( ( ( <span class="number">2</span> * ( ( <span class="number">2</span> * x + <span class="number">3</span> ) % p )  + <span class="number">3</span> ) % p ) ^ ( ( <span class="number">3</span> * ( (  <span class="number">3</span> * y + <span class="number">9</span> ) % p) + <span class="number">9</span> ) % p ) )==s2)</span><br><span class="line"><span class="keyword">while</span> s.check() == sat:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">self.p = <span class="number">4646704883L</span></span><br><span class="line">self.x = x</span><br><span class="line">self.y = y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line"><span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getX</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getY</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.y</span><br><span class="line">m = s.model() <span class="comment"># 解向量</span></span><br><span class="line">pMy = <span class="number">4646704883L</span></span><br><span class="line">myObj = SecurePrng(<span class="built_in">int</span>(<span class="built_in">str</span>(m[x]))%pMy,<span class="built_in">int</span>(<span class="built_in">str</span>(m[y]))%pMy) <span class="comment"># 直接将解传进去，得到下一个结果。事实上这一步是验证解，因为可能有多组解</span></span><br><span class="line">mySol1 = myObj.<span class="built_in">next</span>()</span><br><span class="line">mySol2 = myObj.<span class="built_in">next</span>()</span><br><span class="line"><span class="keyword">if</span> mySol1 == s1cor <span class="keyword">and</span> mySol2 == s2cor <span class="keyword">and</span> <span class="built_in">int</span>(<span class="built_in">str</span>(m[x]))&lt;= pMy <span class="keyword">and</span> <span class="built_in">int</span>(<span class="built_in">str</span>(m[y])) &lt;= pMy :</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;x = &quot;</span> + <span class="built_in">str</span>(m[x]) + <span class="string">&quot; ; y = &quot;</span> + <span class="built_in">str</span>(m[y]) </span><br><span class="line">s.add(Or(x != s.model()[x], y != s.model()[y]))</span><br></pre></td></tr></table></figure><p>下面可以重写PRNG，达到利用的目的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">self.i = <span class="number">0</span></span><br><span class="line">self.p = <span class="number">4646704883L</span></span><br><span class="line">self.x = <span class="number">3714993585</span> % self.p</span><br><span class="line">self.y = <span class="number">2248563082</span> % self.p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="built_in">print</span> self.i</span><br><span class="line">self.i += <span class="number">1</span></span><br><span class="line">self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line"><span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getX</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getY</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.y</span><br></pre></td></tr></table></figure><h1 id="Method-Two"><a href="#Method-Two" class="headerlink" title="Method Two"></a>Method Two</h1><p>上面的方法是很好理解的，但CTFWiki上提供了另外一种方法，目前看来是一种更加值得记录下来，好好理解的方法</p><p>下面是原文摘录</p><blockquote><p>这里我们考虑另外一种方法，<strong>依次从低比特位枚举到高比特位获取 x 的值</strong>，之所以能够这样做，是依赖于这样的观察</p><ul><li>a + b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。<strong>因为第 i 比特位进行运算时，只有可能收到低比特位的进位数值。</strong></li><li>a - b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。<strong>因为第 i 比特位进行运算时，只有可能向低比特位的借位。</strong></li><li>a * b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为这可以视作多次加法。</li><li>a % b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为这可视为多次进行减法。</li><li>a ^ b = c，c 的第 i 比特位的值只受 a 和 b 该比特位的影响。这一点是显而易见的。</li></ul><p><strong>注：个人感觉这个技巧非常有用。</strong></p><p>此外，我们不难得知 p 的比特位为 33 比特位。具体利用思路如下</p><ol><li>首先获取两次猜到的值，这个概率有 0.25。</li><li>依次从低比特位到高比特位依次枚举<strong>第一次迭代后的 x 的相应比特位</strong>。</li><li>根据自己枚举的值分别计算出第二次的值，只有当对应比特位正确，可以将其加入候选正确值。需要注意的是，这里由于取模，所以我们需要枚举到底减了多少次。</li><li>此外，在最终判断时，仍然需要确保对应的值满足一定要求，因为之前对减了多少次进行了枚举。</li></ol></blockquote><p><strong>注：我们主要关注利用思路的第二、三、四三步</strong></p><p>具体利用代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=-<span class="number">1</span>, y=-<span class="number">1</span></span>):</span> <span class="comment"># 题外话，默认值参数真是一个美妙的东西，利用好了可以用来做cache、condition啥的</span></span><br><span class="line">        <span class="comment"># generate seed with 64 bits of entropy</span></span><br><span class="line">        self.p = <span class="number">4646704883L</span>  <span class="comment"># 33bit</span></span><br><span class="line">        <span class="keyword">if</span> x == -<span class="number">1</span>:</span><br><span class="line">            self.x = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.x = x</span><br><span class="line">        <span class="keyword">if</span> y == -<span class="number">1</span>:</span><br><span class="line">            self.y = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">        self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line">        <span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbiti</span>(<span class="params">num, idx</span>):</span> <span class="comment"># idx表达一个类似长度的量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(num)[-idx - <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sp = SecurePrng()</span><br><span class="line">    targetx = sp.x</span><br><span class="line">    targety = sp.y</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;we would like to get x &quot;</span>, targetx</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;we would like to get y &quot;</span>, targety</span><br><span class="line"></span><br><span class="line">    <span class="comment"># suppose we have already guess two number</span></span><br><span class="line">    guess1 = sp.<span class="built_in">next</span>()</span><br><span class="line">    guess2 = sp.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">    p = <span class="number">4646704883</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># newx = tmpx*2+3-kx*p</span></span><br><span class="line">    <span class="keyword">for</span> kx, ky <span class="keyword">in</span> product(<span class="built_in">range</span>(<span class="number">3</span>), <span class="built_in">range</span>(<span class="number">4</span>)): <span class="comment"># 双重循环</span></span><br><span class="line">        candidate = [[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># only 33 bit</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>): <span class="comment"># 第三层循环</span></span><br><span class="line">            <span class="comment">#print &#x27;idx &#x27;, i</span></span><br><span class="line">            new_candidate = []</span><br><span class="line">            <span class="keyword">for</span> old, bit <span class="keyword">in</span> product(candidate, <span class="built_in">range</span>(<span class="number">2</span>)): <span class="comment"># 最深双层循环</span></span><br><span class="line">                <span class="comment">#print old, bit</span></span><br><span class="line">                oldx = old[<span class="number">0</span>]</span><br><span class="line">                <span class="comment">#oldy = old[1]</span></span><br><span class="line">                tmpx = oldx | ((bit &amp; <span class="number">1</span>) &lt;&lt; i) <span class="comment"># <span class="doctag">TODO:</span> 这个遍历方法还需要理解...</span></span><br><span class="line">                <span class="comment">#tmpy = oldy | ((bit / 2) &lt;&lt; i)</span></span><br><span class="line">                tmpy = tmpx ^ guess1 <span class="comment"># seed_x与第一次猜测的结果异或，得到的就是seed_y</span></span><br><span class="line">                newx = tmpx * <span class="number">2</span> + <span class="number">3</span> - kx * p + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>) <span class="comment"># <span class="doctag">TODO:</span> 后面判断的时候也加上了这个条件，这不等价于啥也没干？暂时不太懂</span></span><br><span class="line">                newy = tmpy * <span class="number">3</span> + <span class="number">9</span> - ky * p + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>)</span><br><span class="line">                tmp1 = newx ^ newy</span><br><span class="line">                <span class="comment">#print &quot;tmpx:    &quot;, bin(tmpx)</span></span><br><span class="line">                <span class="comment">#print &quot;targetx: &quot;, bin(targetx)</span></span><br><span class="line">                <span class="comment">#print &quot;calculate:     &quot;, bin(tmp1 + (1 &lt;&lt; 40))</span></span><br><span class="line">                <span class="comment">#print &quot;target guess2: &quot;, bin(guess1 + (1 &lt;&lt; 40))</span></span><br><span class="line">                <span class="keyword">if</span> getbiti(guess2 + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>), i) == getbiti( <span class="comment"># 验证条件，并加入候选解</span></span><br><span class="line">                        tmp1 + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>), i):</span><br><span class="line">                    <span class="keyword">if</span> [tmpx] <span class="keyword">not</span> <span class="keyword">in</span> new_candidate:</span><br><span class="line">                        <span class="comment">#print &quot;got one&quot;</span></span><br><span class="line">                        <span class="comment">#print bin(tmpx)</span></span><br><span class="line">                        <span class="comment">#print bin(targetx)</span></span><br><span class="line">                        <span class="comment">#print bin(tmpy)</span></span><br><span class="line">                        new_candidate.append([tmpx])</span><br><span class="line">            candidate = new_candidate</span><br><span class="line">            <span class="comment">#print len(candidate)</span></span><br><span class="line">            <span class="comment">#print candidate</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;candidate x for kx: &quot;</span>, kx, <span class="string">&quot; ky &quot;</span>, ky</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> candidate: <span class="comment"># 依次验证每个候选解是否由线性同余生成器生成</span></span><br><span class="line">            tmpx = candidate[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            tmpy = tmpx ^ guess1</span><br><span class="line">            <span class="keyword">if</span> tmpx &gt;= p <span class="keyword">or</span> tmpx &gt;= p:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            mysp = SecurePrng(tmpx, tmpy)</span><br><span class="line">            tmp1 = mysp.<span class="built_in">next</span>()</span><br><span class="line">            <span class="keyword">if</span> tmp1 != guess2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">print</span> tmpx, tmpy</span><br><span class="line">            <span class="built_in">print</span>(targetx * <span class="number">2</span> + <span class="number">3</span>) % p, (targety * <span class="number">3</span> + <span class="number">9</span>) % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF-Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Cryptography </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOTES-01】The Elementary of Programming Style</title>
      <link href="2021/05/19/d7392dfa38f0/"/>
      <url>2021/05/19/d7392dfa38f0/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Elementary-of-Programming-Style"><a href="#The-Elementary-of-Programming-Style" class="headerlink" title="The Elementary of Programming Style"></a>The Elementary of Programming Style</h1><blockquote><p>转载自RX师傅的博客<a href="https://www.wootec.top/2019/08/18/The-Elementary-Of-Programming-Style/">The Elementary Of Programming Style - Reverier’s Blog (wootec.top)</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是网上流行的一本绝版书籍,短短几页却浓缩了很多精华.</p><p>即使过了30余年, 其中的思想仍旧在编程时十分有参考价值. 时间挡不住作者的真知灼见.</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>对其中一些内容做了一些注释，方便后面自己看的时候能发现想法的变化</p></blockquote><ul><li><p>把代码写清楚，别耍小聪明。</p><blockquote><p>如果有这种才能，建议出成一个带混淆的逆向题（逃</p></blockquote></li><li><p>想干什么，讲的简单点、直接点。</p><blockquote><p>同上，包括你的命名，函数名，代码结构</p></blockquote></li><li><p>只要有可能，使用库函数。</p><blockquote><p>经常去康康库函数源码，反正我是惊呆了，目前的感受就是在使用python的时候告诉自己，多使用built-in function，能显著简化代码</p></blockquote></li><li><p>避免使用太多的临时变量。</p><blockquote><p>什么tmp啊，temp啊，建议少用点，让人觉得很啰嗦</p></blockquote></li><li><p>“效率”不是牺牲清晰性的理由。</p><blockquote><p>确实，有的时候工程代码和竞赛代码不能一概而论，不要顾此失彼</p></blockquote></li><li><p>让机器去干那些脏活。</p><blockquote><p>emmmmm不解释了，应该懂得</p></blockquote></li><li><p>重复的表达式应该换成函数调用。</p><blockquote><p>这个也是老生常谈了，这样的去重方便了调试，也方便了代码复用</p></blockquote></li><li><p>加上括号、避免歧义。</p><blockquote><p>写c的时候不要因为if后面只有一个表达式就省略大括号</p></blockquote></li><li><p>不要使用含糊不清的变量名。</p><blockquote><p>a, b, c… 完了高血压来了</p></blockquote></li><li><p>把不必要的分支去掉。</p><blockquote><p>这个可能需要一些离散数学的知识，能将一大坨条件判断进行谓词逻辑的等价变换，从而化简分支。事实上很多混淆也是基于这个思路</p></blockquote></li><li><p>使用语言的好特性，不要使用那些糟糕的特性。</p><blockquote><p>目前接触到的语言有限，暂时想到的是python中的各种内置数据结构，可以轻松实现类似有向图的存储等等</p></blockquote></li><li><p>该用逻辑表达式的时候，不要使用过多的条件分支。</p></li><li><p>如果逻辑表达式不好理解，就试着做下变形。</p></li><li><p>选择让程序更简洁的数据表达形式。</p></li><li><p>先用伪代码写，再翻译成你使用的语言。</p><blockquote><p>这就是手写代码的威力啦，不但能用来锻炼对代码的理解，还能用来预构建思路噢</p></blockquote></li><li><p>模块化。使用过程和函数。</p><blockquote><p>建议学习Common Lisp或Scheme类似的极致函数式编程语言，学完感觉看世界都不一样了（虽然我现在有点忘记</p></blockquote></li><li><p>只要你能保证程序的可读性，能不用 goto 就别用 。</p><blockquote><p>逆向中碰到goto的话，会觉得非常莫名其妙，突然就跑飞了。所以同样的，建议出成题目</p></blockquote></li><li><p>不要给糟糕的代码打补丁 - 重写就是了。</p></li><li><p>把大的程序分成一小片一小片来写，分块测试。</p></li><li><p>使用递归程序来处理递归定义的数据结构。</p></li><li><p>正确和错误的输入数据都要测试。</p></li><li><p>确保输入不会超出程序的限制。</p></li><li><p>依靠文件结束来终止输入，而不是依赖一个记数。</p></li><li><p>把文件结束作为一个输入状态来处理。</p></li><li><p>识别出错误的输入；如果有可能就修复它。</p></li><li><p>让输入数据很容易构造出来，让输出数据不言自明。</p></li><li><p>使用统一的输入格式。</p></li><li><p>让输入容易校对。</p></li><li><p>如有可能，提供更自由的输入格式。</p></li><li><p>使用输入提示，允许使用默认值。并把它们显示出来。</p></li><li><p>把输入输出放到子程序里。</p></li><li><p>确保所有的变量在使用前都有初始化。</p></li><li><p>不要因为一个 bug 而停止不前。</p></li><li><p>打开编译程序的调试选项。</p><blockquote><p>对反逆向工程有一点帮助，因为debug模式发布的程序，它的汇编和release版本有很大的差别</p></blockquote></li><li><p>常量结构用数据声明初始化，变量结构用执行代码初始化。</p></li><li><p>小心 off-by-one 错误。</p></li><li><p>当循环中有多个跳出点时要小心。</p></li><li><p>如果什么都不做，那么也要优雅的表现出这个意思。</p></li><li><p>用边界值测试程序。</p><blockquote><p>尽可能刁难你的代码，想一些脑溢血（bushi，才会想到的测试值</p></blockquote></li><li><p>手工检查一些答案。</p><blockquote><p>不管是不是手工吧，你要在脑子里跑一会儿你的程序，以检查时候符合你的预期值</p></blockquote></li><li><p>防御式编程 - 为不可能的情况写几句代码。</p></li><li><p>10.0 乘 0.1 很难保证永远是 1.0 。</p></li><li><p>7/8 等于 0 ，而 7.0/8.0 不等于 0 。</p></li><li><p>不要直接判断两个浮点数相等。</p></li><li><p>先做对，再弄快。</p></li><li><p>先使其可靠，再让其更快。</p></li><li><p>先把代码弄干净，再让它变快。</p></li><li><p>别为了获得一丁点“性能”就牺牲掉整洁。</p></li><li><p>让编译器做些简单的优化。</p><blockquote><p>编译器是很强大的，以gcc为例，有很多关于安全的意想不到的功能</p></blockquote></li><li><p>不要过分追求重用代码；下次用的时候重新组织一下即可。</p></li><li><p>确保特殊的情况是真的特殊。</p><blockquote><p>这个是真的，不要突然考虑到一个情况，就写一个另外的分支；又想到一种情况，又写一个分支…</p></blockquote></li><li><p>保持简洁以获得速度。</p></li><li><p>不要死磕代码来加快速度 - 找个更好的算法。</p></li><li><p>用工具分析你的程序。在做“性能”改进前先评测一下。</p></li><li><p>确保注释和代码一致。</p></li><li><p>不要在注释里仅仅重复代码 - 让每处注释都有价值。</p></li><li><p>不要给糟糕的代码做注释 - 应该重写它。</p><blockquote><p>szyd，至于怎么算糟糕，这个应该能感觉出来吧（</p></blockquote></li><li><p>给变量都起个有意义的名字。</p><blockquote><p>array不如换成src或者dest</p></blockquote></li><li><p>把程序重新整理一下，让阅读代码的人更容易理解。</p><blockquote><p>代码重构是很累的（反正我是这样，但没办法啊，必须得肝</p></blockquote></li><li><p>为你的数据布局写一个文档。</p><blockquote><p>这个暂时没啥想法，类似Android里面的xml？I don’t know…</p></blockquote></li><li><p>不要过分注释。</p><blockquote><p>在《代码简洁之道》中有对于这个的详细解释。因为写的代码一定会有后期维护哒，所以注释不用写得过于详细，比如说对于某个函数，只需要记录他的大致作用就行，而不需要记录诸如，这个变量是干嘛的，那个变量又是干嘛的。因为人都是比较懒的，维护代码的时候，如果你看到的是你一年前写的又臭又长的注释，你会想管它吗？大概率不会。然后受伤的就是用户了</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Style </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming Style </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-03】CISCN2021 Writeup</title>
      <link href="2021/05/16/227ce3facb24/"/>
      <url>2021/05/16/227ce3facb24/</url>
      
        <content type="html"><![CDATA[<h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="glass"><a href="#glass" class="headerlink" title="glass"></a>glass</h2><h3 id="Android部分"><a href="#Android部分" class="headerlink" title="Android部分"></a>Android部分</h3><p>使用jadx-gui反编译附件中的apk，定位到<code>MainActivity</code>，得到</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ciscn.glass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    Button but;</span><br><span class="line">    EditText txt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">checkFlag</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: protected */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.core.app.ComponentActivity, androidx.appcompat.app.AppCompatActivity, androidx.fragment.app.FragmentActivity</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">        setContentView(C0273R.layout.activity_main);</span><br><span class="line">        <span class="keyword">this</span>.but = (Button) findViewById(C0273R.C0275id.button);</span><br><span class="line">        <span class="keyword">this</span>.txt = (EditText) findViewById(C0273R.C0275id.editText);</span><br><span class="line">        <span class="keyword">this</span>.but.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="comment">/* class com.ciscn.glass.MainActivity.View$OnClickListenerC02721 */</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                MainActivity mainActivity = MainActivity.<span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">if</span> (mainActivity.checkFlag(mainActivity.txt.getText().toString())) &#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;right!&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;wrong!&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易发现明显的JNI特征，故将apk解包出来，得到so文件。</p><h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p>拖进IDA，定位到<code>Java_com_ciscn_glass_MainActivity_checkFlag</code>，看看<code>sub_FFC</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_FFC</span><span class="params">(<span class="keyword">char</span> *_box, <span class="keyword">char</span> *_key, <span class="keyword">int</span> _key_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// r6</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// r1</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// r1</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// r3</span></span><br><span class="line">  _BYTE v12[<span class="number">260</span>]; <span class="comment">// [sp+0h] [bp-120h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v12, <span class="number">0</span>, <span class="number">0x100</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">256</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    _box[i] = i;</span><br><span class="line">    sub_126C(i, _key_len);</span><br><span class="line">    v12[i] = _key[v7];</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v8 != <span class="number">256</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = (<span class="keyword">unsigned</span> __int8)_box[v8];</span><br><span class="line">    v9 = (v9 + v10 + (<span class="keyword">unsigned</span> __int8)v12[v8]) % <span class="number">256</span>;</span><br><span class="line">    _box[v8++] = _box[v9];</span><br><span class="line">    _box[v9] = v10;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _stack_chk_guard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现明显的RC4特征，但有所不同</p><h3 id="Angr"><a href="#Angr" class="headerlink" title="Angr"></a>Angr</h3><p>采用一种特殊的办法：将so文件复制下来稍加修改</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *__fastcall <span class="title">sub_10D4</span><span class="params">(<span class="keyword">char</span> *_input, <span class="keyword">int</span> _input_len, <span class="keyword">char</span> *_key, <span class="keyword">int</span> _key_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> *v5;</span><br><span class="line">  <span class="keyword">char</span> v6;</span><br><span class="line">  <span class="keyword">char</span> v7;</span><br><span class="line">  <span class="keyword">char</span> v8;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; _input_len; i += <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = &amp;_input[i];</span><br><span class="line">    v6 = _input[i + <span class="number">2</span>];</span><br><span class="line">    v7 = _input[i + <span class="number">1</span>];</span><br><span class="line">    v8 = _input[i] ^ v6;</span><br><span class="line">    _input[i] = v8;</span><br><span class="line">    v5[<span class="number">2</span>] = v6 ^ v7;</span><br><span class="line">    v5[<span class="number">1</span>] = v7 ^ v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; _input_len; j += _key_len )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; (_key_len &amp; ~(_key_len &gt;&gt; <span class="number">31</span>)) != k &amp;&amp; j + k &lt; _input_len; ++k )</span><br><span class="line">      _input[k] ^= _key[k];</span><br><span class="line">    _input += _key_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *__fastcall <span class="title">sub_1088</span><span class="params">(<span class="keyword">char</span> *_box, <span class="keyword">char</span> *_input, <span class="keyword">int</span> _key_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3;</span><br><span class="line">  <span class="keyword">int</span> v4;</span><br><span class="line">  <span class="keyword">int</span> v5;</span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( _key_len )</span><br><span class="line">  &#123;</span><br><span class="line">    --_key_len;</span><br><span class="line">    v4 = (v4 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    v5 = (<span class="keyword">unsigned</span> __int8)_box[v4];</span><br><span class="line">    v3 = (v3 + v5) % <span class="number">256</span>;</span><br><span class="line">    _box[v4] = _box[v3];</span><br><span class="line">    _box[v3] = v5;</span><br><span class="line">    *_input++ ^= _box[(<span class="keyword">unsigned</span> __int8)(v5 + _box[v4])];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sub_FFC</span><span class="params">(<span class="keyword">char</span> *_box, <span class="keyword">char</span> *_key, <span class="keyword">int</span> _key_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> v8;</span><br><span class="line">  <span class="keyword">int</span> v9;</span><br><span class="line">  <span class="keyword">int</span> v10;</span><br><span class="line">  _BYTE v12[<span class="number">260</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v12, <span class="number">0</span>, <span class="number">0x100</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">256</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    _box[i] = i;</span><br><span class="line">    v12[i] = _key[i % _key_len];</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v8 != <span class="number">256</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = (<span class="keyword">unsigned</span> __int8)_box[v8];</span><br><span class="line">    v9 = (v9 + v10 + (<span class="keyword">unsigned</span> __int8)v12[v8]) % <span class="number">256</span>;</span><br><span class="line">    _box[v8++] = _box[v9];</span><br><span class="line">    _box[v9] = v10;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> key[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> box[<span class="number">260</span>];</span><br><span class="line">    <span class="keyword">char</span> enc[] = &#123;<span class="number">0xA3</span>,<span class="number">0x1A</span>,<span class="number">0xE3</span>,<span class="number">0x69</span>,<span class="number">0x2F</span>,<span class="number">0xBB</span>,<span class="number">0x1A</span>,<span class="number">0x84</span>,<span class="number">0x65</span>,<span class="number">0xC2</span>,<span class="number">0xAD</span>,<span class="number">0xAD</span>,<span class="number">0x9E</span>,<span class="number">0x96</span>,<span class="number">0x05</span>,<span class="number">0x02</span>,<span class="number">0x1F</span>,<span class="number">0x8E</span>,<span class="number">0x36</span>,<span class="number">0x4F</span>,<span class="number">0xE1</span>,<span class="number">0xEB</span>,<span class="number">0xAF</span>,<span class="number">0xF0</span>,<span class="number">0xEA</span>,<span class="number">0xC4</span>,<span class="number">0xA8</span>,<span class="number">0x2D</span>,<span class="number">0x42</span>,<span class="number">0xC7</span>,<span class="number">0x6E</span>,<span class="number">0x3F</span>,<span class="number">0xB0</span>,<span class="number">0xD3</span>,<span class="number">0xCC</span>,<span class="number">0x78</span>,<span class="number">0xF9</span>,<span class="number">0x98</span>,<span class="number">0x3F</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> input[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(input) != <span class="number">39</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Wrong length&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(box, <span class="number">0</span>, <span class="number">256u</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(key, <span class="string">&quot;12345678&quot;</span>, <span class="keyword">sizeof</span>(key));</span><br><span class="line">    <span class="keyword">int</span> key_len = <span class="built_in">strlen</span>(key);</span><br><span class="line">    sub_FFC(box, key, key_len);</span><br><span class="line">    sub_1088(box, input, <span class="number">39</span>);</span><br><span class="line">    sub_10D4(input, <span class="number">39</span>, key, key_len);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(input, enc, <span class="number">0x27</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Congratulations!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ruaaa~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码和原代码作用相同，编译出可执行文件后，使用angr爆破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr, claripy</span><br><span class="line">proj = angr.Project(<span class="string">&#x27;./mod_glass.exe&#x27;</span>, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>:<span class="literal">False</span>&#125;)</span><br><span class="line">flag_chars = [claripy.BVS(<span class="string">&#x27;flag_%d&#x27;</span> % i, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">39</span>)]</span><br><span class="line">flag = claripy.Concat(*flag_chars+[claripy.BVV(<span class="string">b&#x27;\n&#x27;</span>)])</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x4016F9</span>, stdin=flag)</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(avoid=[<span class="number">0x4018D5</span>, <span class="number">0x4017DD</span>], find=<span class="number">0x4018C2</span>)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"><span class="string">b&#x27;CISCN&#123;6654d84617f627c88846c172e0f4d46c&#125;\n&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="baby-bc"><a href="#baby-bc" class="headerlink" title="baby_bc"></a>baby_bc</h2><h3 id="获取ELF文件"><a href="#获取ELF文件" class="headerlink" title="获取ELF文件"></a>获取ELF文件</h3><ul><li>llvm-dis ./baby.bc</li><li>clang ./baby.ll</li></ul><h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>明显的数独特征，有一些限制，手解的，需要了解z3解法与深搜爆破</p>]]></content>
      
      
      <categories>
          
          <category> CTF-Competition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Reverse </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-02】MiniL-CTF-2021</title>
      <link href="2021/05/16/e9933c575dd2/"/>
      <url>2021/05/16/e9933c575dd2/</url>
      
        <content type="html"><![CDATA[<h1 id="Mini-L2021"><a href="#Mini-L2021" class="headerlink" title="Mini-L2021"></a>Mini-L2021</h1><p><strong>URL</strong>: <a href="https://ctf.xidian.edu.cn/#/index">https://ctf.xidian.edu.cn/#/index</a></p><p><strong>Team</strong>: cuttl3fish——kyriota | track | TBMK</p><p><strong>Start Time</strong>: 5.06 20:00</p><p><strong>End Time</strong>: 5.12 20:00</p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="web1-easy-java-kyr"><a href="#web1-easy-java-kyr" class="headerlink" title="web1 easy-java | kyr"></a>web1 easy-java | kyr</h3><p>不会java，枯嘞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">New java.io.BufferedReader(New java.io.FileReader(<span class="string">&quot;/flag&quot;</span>)).readLine()</span><br></pre></td></tr></table></figure><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="抓猫猫-kyr"><a href="#抓猫猫-kyr" class="headerlink" title="抓猫猫 | kyr"></a>抓猫猫 | kyr</h3><blockquote><p> hint：kawaii neko chan says that : what doesn’t kill u makes u stronger</p></blockquote><p>so what u should do is follow what she said , 然后同时连俩 bot 让他们对线，看看谁更腻害</p><h3 id="好白给的签到题-kyr"><a href="#好白给的签到题-kyr" class="headerlink" title="好白给的签到题 | kyr"></a>好白给的签到题 | kyr</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;story.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    fll=flast</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;&#123;&#x27;</span> <span class="keyword">in</span> f <span class="keyword">and</span> <span class="string">b&#x27;&#125;&#x27;</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(f[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        flast=f</span><br><span class="line">        f=base64.b64decode(f)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        flast=fll</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f=base64.b64decode(f[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            f=base64.b64decode(flast[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="土-块-kyr"><a href="#土-块-kyr" class="headerlink" title="土 块 | kyr"></a>土 块 | kyr</h3><p>把题目中的<code>game</code>函数拿出来研究，如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tukuai <span class="keyword">import</span> game</span><br><span class="line">cheat=[[<span class="number">9</span>,[<span class="number">1</span>,<span class="number">0</span>]],[<span class="number">9</span>,[<span class="number">0</span>,<span class="number">1</span>]]]</span><br><span class="line">init_state = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">coin1 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">coin2 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">temp = coin1 * <span class="number">2</span> + coin2</span><br><span class="line">init_state[temp] = <span class="number">1</span></span><br><span class="line">servercoin,qc = game(cheat, init_state)</span><br><span class="line"><span class="built_in">print</span>(coin1)</span><br><span class="line"><span class="built_in">print</span>(coin2)</span><br><span class="line"><span class="built_in">print</span>(init_state)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my coin is &#x27;</span> + <span class="built_in">str</span>(servercoin) + <span class="string">&#x27; your coin is?&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_bloch_multivector</span><br><span class="line">display(plot_bloch_multivector(init_state))</span><br><span class="line">simulator=Aer.get_backend(<span class="string">&#x27;qasm_simulator&#x27;</span>)</span><br><span class="line">result=execute(qc,backend=simulator).result()</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_histogram</span><br><span class="line">display(qc.draw(output=<span class="string">&#x27;mpl&#x27;</span>))</span><br><span class="line">display(plot_histogram(result.get_counts(qc)))</span><br></pre></td></tr></table></figure><p>画出几个图出来看看，只要绘出 bot 的输出 = my coin 的量子电路即可，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌──────────────────────┐┌───┐        </span><br><span class="line">q12_0: ┤0                     ├┤ X ├──■─────</span><br><span class="line">       │  initialize(0,0,1,0) │└─┬─┘┌─┴─┐┌─┐</span><br><span class="line">q12_1: ┤1                     ├──■──┤ X ├┤M├</span><br><span class="line">       └──────────────────────┘     └───┘└╥┘</span><br><span class="line"> c1: 1&#x2F;═══════════════════════════════════╩═</span><br><span class="line">                                          0 </span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="0oooops-track"><a href="#0oooops-track" class="headerlink" title="0oooops | track"></a>0oooops | track</h3><blockquote><p>这道题涉及到windows的异常处理机制SEH</p></blockquote><h4 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h4><p>这个题不涉及太多SEH的底层，大概有以下几个点需要了解的：</p><ul><li>SEH实际包含两个主要功能：结束处理（termination handling）和异常处理（exception handling)</li><li>每当你建立一个try块，它必须跟随一个 <code>__finally</code>块或一个<code>__except</code>块。</li><li>一个<code>try</code>块之后不能既有finally块又有except块。但可以在try-except块中嵌套try-finally块，反过来 也可以。</li><li><code>__try</code>,<code>__finally</code>关键字用来标出结束处理程序两段代码的轮廓<br>不管保护体（try块） 是如何退出的。不论你在保护体中使用return，还是goto，或者是longjump，结束处理程序 （finally块）都将被调用。</li><li>在try使用<code>__leave</code>关键字会引起跳转到try块的结尾</li><li>给<code>ms_exc.registration.TryLevel</code>赋值是用于处理嵌套的try</li></ul><blockquote><p>学习自HAPPY师傅的博客</p></blockquote><p>然后看看题，main函数直接看发现异常，于是看汇编，定位到伪代码异常处。IDA的分析结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00412330 loc_412330:                             ; CODE XREF: _main_0+15C↑j</span><br><span class="line">.text:00412330 ;   __try &#123; &#x2F;&#x2F; __except at loc_412377</span><br><span class="line">.text:00412330                 mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:00412337                 lea     ebx, [ebp+Str]</span><br><span class="line">.text:0041233D                 xor     eax, eax</span><br><span class="line">.text:0041233F                 db      3Eh</span><br><span class="line">.text:0041233F                 mov     dword ptr [eax], 0</span><br><span class="line">.text:00412346                 mov     edx, 0</span><br><span class="line">.text:0041234B                 div     edx</span><br></pre></td></tr></table></figure><p>发现非常明显的<strong>除零异常</strong>还有<strong>eax清零后却试图访问它的内存</strong>，以及SEH结构。不需要对它进行任何patch，因为必须让程序捕获到这个异常，才会去执行<code>__except_filter</code>，也就是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text:00412356 loc_412356:                             ; DATA XREF: .rdata:stru_41A238↓o</span><br><span class="line">.text:00412356 ;   __except filter &#x2F;&#x2F; owned by 412330</span><br><span class="line">.text:00412356                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:00412359                 mov     ecx, [eax]</span><br><span class="line">.text:0041235B                 mov     edx, [ecx]</span><br><span class="line">.text:0041235D                 mov     [ebp+var_1BC], edx</span><br><span class="line">.text:00412363                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:00412366                 push    eax</span><br><span class="line">.text:00412367                 mov     ecx, [ebp+var_1BC]</span><br><span class="line">.text:0041236D                 push    ecx</span><br><span class="line">.text:0041236E                 call    sub_411131</span><br><span class="line">.text:00412373                 add     esp, 8</span><br><span class="line">.text:00412376                 retn</span><br></pre></td></tr></table></figure><p>稍微看一看<code>sub_411131</code>函数的内部逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_411DD0</span><span class="params">(<span class="keyword">int</span> a1, _EXCEPTION_POINTERS *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a2-&gt;ExceptionRecord-&gt;ExceptionCode != <span class="number">0xC0000094</span> ) <span class="comment">// 除零异常相应的异常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5 = (<span class="keyword">char</span> *)(a2-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>);</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != ((<span class="keyword">unsigned</span> __int8)a2-&gt;ContextRecord-&gt;Eip ^ ((v5[<span class="number">2</span> * i + <span class="number">1</span>] ^ <span class="number">0x4D</span>) - <span class="number">4</span>) ^ <span class="number">0x13</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a2-&gt;ContextRecord-&gt;Eip += <span class="number">54</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a2-&gt;ContextRecord-&gt;Eip += <span class="number">63</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现将运算结果存在v5中，但是只有奇数位，不妨试着还原一下（伪代码）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> magic_1[] = <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_1[i] ^ 0x13 ^ errr_addr)+4)^0x4d);</span></span><br><span class="line">        flag[<span class="number">2</span> * i + <span class="number">1</span>] = ((magic_1[i] ^ <span class="number">0x13</span> ^ errr_addr)+<span class="number">4</span>)^<span class="number">0x4d</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并且如果满足条件，将会改变eip的值，将进程从异常中跳出来，不妨看看跳到了哪里</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">0x41234B</span> + <span class="number">63</span>))</span><br></pre></td></tr></table></figure><p>那里是congratulations的提示信息，但很明显我们还没拿到完整的flag</p><h4 id="VEH-amp-amp-TLS"><a href="#VEH-amp-amp-TLS" class="headerlink" title="VEH &amp;&amp; TLS"></a>VEH &amp;&amp; TLS</h4><p>查看IDA的Exports窗口可以看到TlsCallback_0_0</p><blockquote><p>TLS，Thread Local Storage 线程局部存储，TLS回调函数的调用运行要先于PE代码执行，该特性使它可以作为一种反调试技术使用。</p><p>TLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据。</p></blockquote><p>return了一个奇怪的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID __stdcall <span class="title">TlsCallback_0_0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">return</span> AddVectoredExceptionHandler(<span class="number">1u</span>, Handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attributes: thunk</span></span><br><span class="line"><span class="function">LONG __stdcall <span class="title">Handler</span><span class="params">(struct _EXCEPTION_POINTERS *ExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_411BD0(ExceptionInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">sub_411BD0</span><span class="params">(_EXCEPTION_POINTERS *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h]</span></span><br><span class="line">  DWORD v4; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a1-&gt;ExceptionRecord-&gt;ExceptionCode != <span class="number">0xC0000005</span> ) <span class="comment">// 不可访问地址相应的异常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v4 = a1-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>;</span><br><span class="line">  v3[<span class="number">0</span>] = <span class="number">16</span>;</span><br><span class="line">  v3[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">  v3[<span class="number">2</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">  v3[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">  v3[<span class="number">6</span>] = <span class="number">4</span>;</span><br><span class="line">  v3[<span class="number">7</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">8</span>] = <span class="number">11</span>;</span><br><span class="line">  v3[<span class="number">9</span>] = <span class="number">5</span>;</span><br><span class="line">  v3[<span class="number">10</span>] = <span class="number">31</span>;</span><br><span class="line">  v3[<span class="number">11</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">12</span>] = <span class="number">33</span>;</span><br><span class="line">  v3[<span class="number">13</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">14</span>] = <span class="number">72</span>;</span><br><span class="line">  v3[<span class="number">15</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">16</span>] = <span class="number">6</span>;</span><br><span class="line">  v3[<span class="number">17</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">18</span>] = <span class="number">17</span>;</span><br><span class="line">  v3[<span class="number">19</span>] = <span class="number">69</span>;</span><br><span class="line">  v3[<span class="number">20</span>] = <span class="number">5</span>;</span><br><span class="line">  v3[<span class="number">21</span>] = <span class="number">62</span>;</span><br><span class="line">  v3[<span class="number">22</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">23</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">24</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">25</span>] = <span class="number">72</span>;</span><br><span class="line">  v3[<span class="number">26</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">27</span>] = <span class="number">69</span>;</span><br><span class="line">  v3[<span class="number">28</span>] = <span class="number">33</span>;</span><br><span class="line">  v3[<span class="number">29</span>] = <span class="number">31</span>;</span><br><span class="line">  v3[<span class="number">30</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v3[i] != (((*(<span class="keyword">char</span> *)(v4 + <span class="number">2</span> * i) ^ <span class="number">0x37</span>) + <span class="number">4</span>) ^ <span class="number">0x42</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a1-&gt;ContextRecord-&gt;Eip += <span class="number">66</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a1-&gt;ContextRecord-&gt;Eip += <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Handler显然是第二段解密），因为我实在是太菜了，又查了一下这个函数的功能，发现了另一个异常处理机制VEH</p><p>VEH处理流程</p><blockquote><ul><li>CPU捕获异常信息</li><li>通过KiDispatchException进行分发(EIP=KiUserExceptionDispatcher)</li><li>KiUserExceptionDispatcher调用RtIDispatchException.</li><li>RtIDispatchException查找VEH处理函数链表并调用相关处理函数</li><li>代码返回到KiUserExceptionDispatcher</li><li>调用ZwContinue再次进入0环(ZwContinue调用NtContinue,主要作用就是恢复 TRAPFRAME然后通过_KiServiceExit返回到3环)。</li><li>线程再次返回3环后,从修正后的位置开始执行</li></ul><p>学习自：<a href="https://blog.csdn.net/weixin_42052102/article/details/83540134">https://blog.csdn.net/weixin_42052102/article/details/83540134</a></p></blockquote><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p><strong>这样一来整个流程大致明了了</strong></p><ul><li>VEH抓到<code>0xC0000005</code></li><li>SEH抓到<code>0xC0000094</code></li><li>分别的flag在各自的handler里面</li></ul><p>脚本如下，写的比较乱</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> errr_addr = <span class="number">0x30234B</span>;</span><br><span class="line">    <span class="keyword">char</span> magic_1[] = <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_1[i] ^ 0x13 ^ errr_addr)+4)^0x4d);</span></span><br><span class="line">        flag[<span class="number">2</span> * i + <span class="number">1</span>] = ((magic_1[i] ^ <span class="number">0x13</span> ^ errr_addr)+<span class="number">4</span>)^<span class="number">0x4d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> magic_2[] = &#123;<span class="number">16</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">4</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">31</span>,<span class="number">46</span>,<span class="number">33</span>,<span class="number">46</span>,<span class="number">72</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">17</span>,<span class="number">69</span>,<span class="number">5</span>,<span class="number">62</span>,<span class="number">46</span>,<span class="number">24</span>,<span class="number">21</span>,<span class="number">72</span>,<span class="number">46</span>,<span class="number">69</span>,<span class="number">33</span>,<span class="number">31</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_2[i]^0x42)-4)^0x37);</span></span><br><span class="line">        flag[<span class="number">2</span> * i] = ((magic_2[i]^<span class="number">0x42</span>)<span class="number">-4</span>)^<span class="number">0x37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    <span class="comment">// miniLctf&#123;y0u_a1r4ady_und4rstand_th4_w1nd0ws_exc4pt1On_handl1e_m4chan1sm&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sub-track"><a href="#sub-track" class="headerlink" title="sub | track"></a>sub | track</h3><blockquote><p>傀儡进程</p></blockquote><h4 id="Pre-check"><a href="#Pre-check" class="headerlink" title="Pre_check"></a>Pre_check</h4><p>这题居然让我电脑报毒了，让我康康！（康不懂，爬了</p><p>main函数很混乱，但仔细看能看出一点东西，貌似是创建一个进程，尝试把另一个文件读进来，然后开始执行？还看见一个熟悉的SMC</p><p>看了hint之后搜到了傀儡进程，一个最基本傀儡进程的实现如下</p><ul><li>CreateProcess创建进程，传入参数CREATE_SUSPENDED使进程挂起</li><li>NtUnmapViewOfSection清空新进程的内存数据</li><li>VirtualAllocEx申请新的内存</li><li>WriteProcessMemory向内存写入payload</li><li>SetThreadContext设置入口点</li><li>ResumeThread唤醒进程，执行payload</li></ul><h4 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h4><p>emmm直接调的话，由于各种奇怪的反调试，好像没法成功，于是我打开了010editor，直接把傀儡进程在运行前全都异或回去，并dump出来单独分析</p><p>清晰的main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main_0</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> input_len; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+0h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [esp+0h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">char</span> input[<span class="number">56</span>]; <span class="comment">// [esp+D0h] [ebp-3Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_40C015);</span><br><span class="line">  <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0x32</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input your flag: &quot;</span>, v5);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="keyword">char</span>)input);</span><br><span class="line">  input_len = <span class="built_in">strlen</span>(input);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)off_40A040(input, input_len) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulation~~~&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Try again~~~&quot;</span>, v6);</span><br><span class="line">  getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>off_40A040</code>一路往下点，就看到加密逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> __cdecl <span class="title">sub_4014F0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+DCh] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_40C015);</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">char</span>)(((*(_BYTE *)(i + a1) ^ <span class="number">0x66</span>) + <span class="number">4</span>) ^ <span class="number">0x55</span>) != byte_40A020[i] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺常规的，直接还原？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic_1 = [<span class="number">0x5A</span>,<span class="number">0x46</span>,<span class="number">0x59</span>,<span class="number">0x46</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x74</span>,<span class="number">0x63</span>,<span class="number">0x47</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x43</span>,<span class="number">0x47</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x5E</span>,<span class="number">0x44</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_1)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(((magic_1[i] ^ <span class="number">0x55</span>) -<span class="number">4</span>) ^ <span class="number">0x66</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># miniLctf&#123;Th1s_1s_th4_fak4_f1ag!&#125;</span></span><br></pre></td></tr></table></figure><p>我aklsjdaiwjdawijdaiwdjqw（</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><p>又是上一题一样的，在Exports里面有<code>TlsCallback_0_0</code></p><p>里面有对于<code>off_40A040</code>的指向进行处理，然后就没啥问题了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic_1 = [<span class="number">0x5A</span>,<span class="number">0x46</span>,<span class="number">0x59</span>,<span class="number">0x46</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x74</span>,<span class="number">0x63</span>,<span class="number">0x47</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x43</span>,<span class="number">0x47</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x5E</span>,<span class="number">0x44</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">fake_flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_1)):</span><br><span class="line">    fake_flag += <span class="built_in">chr</span>(((magic_1[i] ^ <span class="number">0x55</span>) -<span class="number">4</span>) ^ <span class="number">0x66</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_flag)</span><br><span class="line"></span><br><span class="line">magic_2=[<span class="number">0x5A</span>,<span class="number">0x26</span>,<span class="number">0x59</span>,<span class="number">0x26</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x54</span>,<span class="number">0x6D</span>,<span class="number">0x52</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x4C</span>,<span class="number">0x0F</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x43</span>,<span class="number">0x03</span>,<span class="number">0x4D</span>,<span class="number">0x03</span>,<span class="number">0x4C</span>,<span class="number">0x43</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_2)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(((magic_2[i] ^ <span class="number">0x66</span>) - <span class="number">4</span>) ^ <span class="number">0x55</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1><p>还是太菜了，虽然是校内rk3，但这分数太惨了，加油加油！</p>]]></content>
      
      
      <categories>
          
          <category> CTF-Competition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-01】NPUCTF2020-BabyObfuscation</title>
      <link href="2021/04/21/eec6d01d64db/"/>
      <url>2021/04/21/eec6d01d64db/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-1-查壳"><a href="#Step-1-查壳" class="headerlink" title="Step 1: 查壳"></a>Step 1: 查壳</h1><ol><li>发现是64位程序，无壳</li><li>运行程序提示为”WHERE IS MY KEY!?”</li></ol><h1 id="Step-2-IDA加载初步判断功能"><a href="#Step-2-IDA加载初步判断功能" class="headerlink" title="Step 2: IDA加载初步判断功能"></a>Step 2: IDA加载初步判断功能</h1><p><code>main</code>函数直接F5看的话，是这样一坨浆糊</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">bool</span> v18; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v22; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v26; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v28[<span class="number">68</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> Str[<span class="number">1008</span>]; <span class="comment">// [rsp+130h] [rbp+B0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v30[<span class="number">1008</span>]; <span class="comment">// [rsp+520h] [rbp+4A0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v31[<span class="number">4</span>]; <span class="comment">// [rsp+14E0h] [rbp+1460h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+14F0h] [rbp+1470h]</span></span><br><span class="line">  <span class="keyword">int</span> k; <span class="comment">// [rsp+14F4h] [rbp+1474h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+14F8h] [rbp+1478h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14FCh] [rbp+147Ch]</span></span><br><span class="line"></span><br><span class="line">  _main(argc, argv, envp);</span><br><span class="line">  <span class="built_in">memset</span>(v30, <span class="number">0</span>, <span class="number">0xFA0</span>ui64);</span><br><span class="line">  v30[<span class="number">1000</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v28, <span class="number">0</span>, <span class="number">0x100</span>ui64);</span><br><span class="line">  v28[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">64</span>; ++i )</span><br><span class="line">    v28[i] = i + <span class="number">1</span>;</span><br><span class="line">  v31[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  v31[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">  v31[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">  v31[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">  v30[<span class="number">1004</span>] = <span class="number">2</span>;</span><br><span class="line">  v30[<span class="number">1005</span>] = <span class="number">3</span>;</span><br><span class="line">  v30[<span class="number">1006</span>] = <span class="number">4</span>;</span><br><span class="line">  v30[<span class="number">1007</span>] = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;WHERE IS MY KEY!?&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%32s&quot;</span>, Str);</span><br><span class="line">  v32 = <span class="built_in">strlen</span>(Str);</span><br><span class="line">  v3 = F0X1(v28[j], v28[j]);</span><br><span class="line">  <span class="keyword">for</span> ( j = v3 / v28[j]; j &lt;= v32; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (v28[j] + v28[j + <span class="number">1</span>]) * (v28[j] + v28[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt;= (<span class="keyword">int</span>)(F0X5(<span class="number">2</span>, <span class="number">2</span>) * v28[j] * v28[j + <span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = ~Str[(<span class="keyword">int</span>)F0X4(j, <span class="number">1</span>)];</span><br><span class="line">      v6 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] = ~(v5 + v31[v6 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = F0X1(v28[j], v28[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; (<span class="keyword">int</span>)F0X1(v28[j + <span class="number">1</span>], ~(~v28[j + <span class="number">1</span>] + v28[j])) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v30[j];</span><br><span class="line">      v9 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] = ~(~v8 + v28[v9 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]) * v8;</span><br><span class="line">    &#125;</span><br><span class="line">    v10 = v28[j + <span class="number">1</span>];</span><br><span class="line">    v11 = F0X5(<span class="number">2</span>, <span class="number">1</span>) * v10;</span><br><span class="line">    v12 = v28[j];</span><br><span class="line">    v13 = F0X5(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    v14 = F0X1(v12 * v13, v11);</span><br><span class="line">    v15 = F0X5(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v14 == v15 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X1(v28[j], v28[j + <span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] ^= v31[v16 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = F0X5(V0X3, v28[j]);</span><br><span class="line">    v18 = v17 &lt; v28[j] + <span class="number">1</span>;</span><br><span class="line">    v19 = F0X5(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)F0X3(v19 &gt;= j, v18) )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = ~Str[(<span class="keyword">int</span>)F0X4(j, <span class="number">1</span>)];</span><br><span class="line">      v21 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] ^= ~(v20 + v31[v21 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    v22 = F0X5(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    v23 = F0X1(v28[j], v28[j]);</span><br><span class="line">    v30[j] *= v22 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X5(<span class="number">2</span>, v23 / v28[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  v24 = F0X5(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X4(v24, <span class="number">1</span>) != v32 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  v25 = F0X1(v28[k], v28[k]);</span><br><span class="line">  <span class="keyword">for</span> ( k = v25 / v28[k]; k &lt;= v32; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    v26 = v30[k];</span><br><span class="line">    <span class="keyword">if</span> ( v26 == (<span class="keyword">int</span>)F0X4(A0X6[k], <span class="number">1</span>) / <span class="number">10</span> )</span><br><span class="line">      ++V0X2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( V0X2 == v32 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nPASS&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_23:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nDENIED&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看<code>F0X1</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">    result = F0X1(a2, (<span class="keyword">int</span>)a1 % a2);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = a1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个递归函数容易发现是在求a1和a2的最大公因数gcd</p><p>然后是<code>F0X5</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X5</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (a2 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      v4 *= a1;</span><br><span class="line">    a1 *= a1;</span><br><span class="line">    a2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也比较容易看出来，就是在求a1的a2次方pow</p><p>接着是<code>F0X4</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X4</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)~(~a1 + a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于两个int而言，这个结构等价于a1-a2</p><p>继续看<code>F0X3</code>和<code>F0X2</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall F0X3(bool a1, bool a2)</span><br><span class="line">&#123;</span><br><span class="line">  char v2; &#x2F;&#x2F; bl</span><br><span class="line">  char v3; &#x2F;&#x2F; al</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; F0X2(a2, a2);</span><br><span class="line">  v3 &#x3D; F0X2(a1, a1);</span><br><span class="line">  return F0X2(v3, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_BOOL8 __fastcall F0X2(char a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  return a1 &#x3D;&#x3D; a2 &amp;&amp; a1 !&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个需要稍微推导一下，可以看出等价于a1&amp;a2</p><blockquote><p>对于函数的功能，可以考虑复制下来，然后测试一下，再结合推导，就能比较容易的判断出函数的功能了</p></blockquote><p>于是进行重命名</p><p><img src="https://i.loli.net/2021/04/21/lneU2O8a6YhrpVC.png" alt="p1.png"></p><h1 id="Step-3-判断条件跳转"><a href="#Step-3-判断条件跳转" class="headerlink" title="Step 3: 判断条件跳转"></a>Step 3: 判断条件跳转</h1><ul><li><p>第一处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v4 = (v28[j] + v28[j + <span class="number">1</span>]) * (v28[j] + v28[j + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ( v4 &gt;= (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2</span>) * v28[j] * v28[j + <span class="number">1</span>]) )</span><br></pre></td></tr></table></figure><p>抽象出来即</p><script type="math/tex; mode=display">(x + y) ^ 2 \ge 4xy</script><p>这是永真的，也就是下面的代码块永远会被执行</p></li><li><p>第二处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v7 = gcd(v28[j], v28[j + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ( v7 &gt; (<span class="keyword">int</span>)gcd(v28[j + <span class="number">1</span>], ~(~v28[j + <span class="number">1</span>] + v28[j])) )</span><br></pre></td></tr></table></figure><p>等价于</p><script type="math/tex; mode=display">gcd(x, y) > gcd(y, x-y)</script><p>左右两边显然是一样的，所以下面的代码块不可能执行</p></li><li><p>第三处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v10 = v28[j + <span class="number">1</span>];</span><br><span class="line">v11 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>) * v10;</span><br><span class="line">v12 = v28[j];</span><br><span class="line">v13 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">v14 = gcd(v12 * v13, v11);</span><br><span class="line">v15 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ( v14 == v15 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)gcd(v28[j], v28[j + <span class="number">1</span>]) )</span><br></pre></td></tr></table></figure><p>等价于</p><script type="math/tex; mode=display">gcd(2x, 2y) = 2gcd(x, y)</script><p>这也是永真的，故下面的代码块一定执行</p></li><li><p>第四处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v17 = <span class="built_in">pow</span>(V0X3, v28[j]);</span><br><span class="line">v18 = v17 &lt; v28[j] + <span class="number">1</span>;</span><br><span class="line">v19 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)AND(v19 &gt;= j, v18) )</span><br><span class="line"><span class="comment">//其中V0X3 == 3</span></span><br><span class="line"><span class="comment">//这里需要看看后面关于整个key长度的判断，这里就不说明了</span></span><br></pre></td></tr></table></figure><p>key长度是15故<code>v19 &gt;= j</code>必定成立</p><p>于是只需判断</p><script type="math/tex; mode=display">f(x)=3^x - x - 1 <0</script><p>求导或者直接画图都能判断出该条件为假，则下面的代码块不会执行</p></li><li><p><strong>综上</strong></p><p>只有三处代码有效</p><p><img src="https://i.loli.net/2021/04/21/i19yFkjOEmha56R.png" alt="p2.png"></p></li></ul><p>最终是这样的效果</p><h1 id="Step-4-exp"><a href="#Step-4-exp" class="headerlink" title="Step 4: exp"></a>Step 4: exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enc = [<span class="number">780</span>, <span class="number">780</span>, <span class="number">850</span>, <span class="number">590</span>, <span class="number">800</span>, <span class="number">640</span>, <span class="number">1150</span>, <span class="number">460</span>, <span class="number">980</span>, <span class="number">960</span>, <span class="number">1170</span>, <span class="number">530</span>, <span class="number">970</span>, <span class="number">1080</span>, <span class="number">1250</span>]</span><br><span class="line">vec = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i] = enc[i] // <span class="number">10</span>;</span><br><span class="line">    enc[i] ^= vec[i%<span class="number">4</span>]</span><br><span class="line">    enc[i] += vec[i%<span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc[i]), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1>]]></content>
      
      
      <categories>
          
          <category> CTF-Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Reverse </tag>
            
            <tag> WP </tag>
            
            <tag> BUUOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>whoami</title>
      <link href="2021/04/14/2390e06bacb2/"/>
      <url>2021/04/14/2390e06bacb2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">track</span><br></pre></td></tr></table></figure><p>来自XDSEC的大一逆向工程菜鸡</p><p>正努力追赶带佬们的脚步</p>]]></content>
      
      
      
        <tags>
            
            <tag> 简介 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
