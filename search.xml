<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【WP-02】MiniL-CTF-2021</title>
      <link href="2021/05/16/e9933c575dd2/"/>
      <url>2021/05/16/e9933c575dd2/</url>
      
        <content type="html"><![CDATA[<h1 id="Mini-L2021"><a href="#Mini-L2021" class="headerlink" title="Mini-L2021"></a>Mini-L2021</h1><p><strong>URL</strong>: <a href="https://ctf.xidian.edu.cn/#/index">https://ctf.xidian.edu.cn/#/index</a></p><p><strong>Team</strong>: cuttl3fish——kyriota | track | TBMK</p><p><strong>Start Time</strong>: 5.06 20:00</p><p><strong>End Time</strong>: 5.12 20:00</p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="web1-easy-java-kyr"><a href="#web1-easy-java-kyr" class="headerlink" title="web1 easy-java | kyr"></a>web1 easy-java | kyr</h3><p>不会java，枯嘞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">New java.io.BufferedReader(New java.io.FileReader(<span class="string">&quot;/flag&quot;</span>)).readLine()</span><br></pre></td></tr></table></figure><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="抓猫猫-kyr"><a href="#抓猫猫-kyr" class="headerlink" title="抓猫猫 | kyr"></a>抓猫猫 | kyr</h3><blockquote><p> hint：kawaii neko chan says that : what doesn’t kill u makes u stronger</p></blockquote><p>so what u should do is follow what she said , 然后同时连俩 bot 让他们对线，看看谁更腻害</p><h3 id="好白给的签到题-kyr"><a href="#好白给的签到题-kyr" class="headerlink" title="好白给的签到题 | kyr"></a>好白给的签到题 | kyr</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;story.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    fll=flast</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;&#123;&#x27;</span> <span class="keyword">in</span> f <span class="keyword">and</span> <span class="string">b&#x27;&#125;&#x27;</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(f[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        flast=f</span><br><span class="line">        f=base64.b64decode(f)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        flast=fll</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f=base64.b64decode(f[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            f=base64.b64decode(flast[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="土-块-kyr"><a href="#土-块-kyr" class="headerlink" title="土 块 | kyr"></a>土 块 | kyr</h3><p>把题目中的<code>game</code>函数拿出来研究，如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tukuai <span class="keyword">import</span> game</span><br><span class="line">cheat=[[<span class="number">9</span>,[<span class="number">1</span>,<span class="number">0</span>]],[<span class="number">9</span>,[<span class="number">0</span>,<span class="number">1</span>]]]</span><br><span class="line">init_state = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">coin1 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">coin2 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">temp = coin1 * <span class="number">2</span> + coin2</span><br><span class="line">init_state[temp] = <span class="number">1</span></span><br><span class="line">servercoin,qc = game(cheat, init_state)</span><br><span class="line"><span class="built_in">print</span>(coin1)</span><br><span class="line"><span class="built_in">print</span>(coin2)</span><br><span class="line"><span class="built_in">print</span>(init_state)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my coin is &#x27;</span> + <span class="built_in">str</span>(servercoin) + <span class="string">&#x27; your coin is?&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_bloch_multivector</span><br><span class="line">display(plot_bloch_multivector(init_state))</span><br><span class="line">simulator=Aer.get_backend(<span class="string">&#x27;qasm_simulator&#x27;</span>)</span><br><span class="line">result=execute(qc,backend=simulator).result()</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_histogram</span><br><span class="line">display(qc.draw(output=<span class="string">&#x27;mpl&#x27;</span>))</span><br><span class="line">display(plot_histogram(result.get_counts(qc)))</span><br></pre></td></tr></table></figure><p>画出几个图出来看看，只要绘出 bot 的输出 = my coin 的量子电路即可，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌──────────────────────┐┌───┐        </span><br><span class="line">q12_0: ┤0                     ├┤ X ├──■─────</span><br><span class="line">       │  initialize(0,0,1,0) │└─┬─┘┌─┴─┐┌─┐</span><br><span class="line">q12_1: ┤1                     ├──■──┤ X ├┤M├</span><br><span class="line">       └──────────────────────┘     └───┘└╥┘</span><br><span class="line"> c1: 1&#x2F;═══════════════════════════════════╩═</span><br><span class="line">                                          0 </span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="0oooops-track"><a href="#0oooops-track" class="headerlink" title="0oooops | track"></a>0oooops | track</h3><blockquote><p>这道题涉及到windows的异常处理机制SEH</p></blockquote><h4 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h4><p>这个题不涉及太多SEH的底层，大概有以下几个点需要了解的：</p><ul><li>SEH实际包含两个主要功能：结束处理（termination handling）和异常处理（exception handling)</li><li>每当你建立一个try块，它必须跟随一个 <code>__finally</code>块或一个<code>__except</code>块。</li><li>一个<code>try</code>块之后不能既有finally块又有except块。但可以在try-except块中嵌套try-finally块，反过来 也可以。</li><li><code>__try</code>,<code>__finally</code>关键字用来标出结束处理程序两段代码的轮廓<br>不管保护体（try块） 是如何退出的。不论你在保护体中使用return，还是goto，或者是longjump，结束处理程序 （finally块）都将被调用。</li><li>在try使用<code>__leave</code>关键字会引起跳转到try块的结尾</li><li>给<code>ms_exc.registration.TryLevel</code>赋值是用于处理嵌套的try</li></ul><blockquote><p>学习自HAPPY师傅的博客</p></blockquote><p>然后看看题，main函数直接看发现异常，于是看汇编，定位到伪代码异常处。IDA的分析结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00412330 loc_412330:                             ; CODE XREF: _main_0+15C↑j</span><br><span class="line">.text:00412330 ;   __try &#123; &#x2F;&#x2F; __except at loc_412377</span><br><span class="line">.text:00412330                 mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:00412337                 lea     ebx, [ebp+Str]</span><br><span class="line">.text:0041233D                 xor     eax, eax</span><br><span class="line">.text:0041233F                 db      3Eh</span><br><span class="line">.text:0041233F                 mov     dword ptr [eax], 0</span><br><span class="line">.text:00412346                 mov     edx, 0</span><br><span class="line">.text:0041234B                 div     edx</span><br></pre></td></tr></table></figure><p>发现非常明显的<strong>除零异常</strong>还有<strong>eax清零后却试图访问它的内存</strong>，以及SEH结构。不需要对它进行任何patch，因为必须让程序捕获到这个异常，才会去执行<code>__except_filter</code>，也就是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text:00412356 loc_412356:                             ; DATA XREF: .rdata:stru_41A238↓o</span><br><span class="line">.text:00412356 ;   __except filter &#x2F;&#x2F; owned by 412330</span><br><span class="line">.text:00412356                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:00412359                 mov     ecx, [eax]</span><br><span class="line">.text:0041235B                 mov     edx, [ecx]</span><br><span class="line">.text:0041235D                 mov     [ebp+var_1BC], edx</span><br><span class="line">.text:00412363                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:00412366                 push    eax</span><br><span class="line">.text:00412367                 mov     ecx, [ebp+var_1BC]</span><br><span class="line">.text:0041236D                 push    ecx</span><br><span class="line">.text:0041236E                 call    sub_411131</span><br><span class="line">.text:00412373                 add     esp, 8</span><br><span class="line">.text:00412376                 retn</span><br></pre></td></tr></table></figure><p>稍微看一看<code>sub_411131</code>函数的内部逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_411DD0</span><span class="params">(<span class="keyword">int</span> a1, _EXCEPTION_POINTERS *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a2-&gt;ExceptionRecord-&gt;ExceptionCode != <span class="number">0xC0000094</span> ) <span class="comment">// 除零异常相应的异常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5 = (<span class="keyword">char</span> *)(a2-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>);</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != ((<span class="keyword">unsigned</span> __int8)a2-&gt;ContextRecord-&gt;Eip ^ ((v5[<span class="number">2</span> * i + <span class="number">1</span>] ^ <span class="number">0x4D</span>) - <span class="number">4</span>) ^ <span class="number">0x13</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a2-&gt;ContextRecord-&gt;Eip += <span class="number">54</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a2-&gt;ContextRecord-&gt;Eip += <span class="number">63</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现将运算结果存在v5中，但是只有奇数位，不妨试着还原一下（伪代码）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> magic_1[] = <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_1[i] ^ 0x13 ^ errr_addr)+4)^0x4d);</span></span><br><span class="line">        flag[<span class="number">2</span> * i + <span class="number">1</span>] = ((magic_1[i] ^ <span class="number">0x13</span> ^ errr_addr)+<span class="number">4</span>)^<span class="number">0x4d</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并且如果满足条件，将会改变eip的值，将进程从异常中跳出来，不妨看看跳到了哪里</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">0x41234B</span> + <span class="number">63</span>))</span><br></pre></td></tr></table></figure><p>那里是congratulations的提示信息，但很明显我们还没拿到完整的flag</p><h4 id="VEH-amp-amp-TLS"><a href="#VEH-amp-amp-TLS" class="headerlink" title="VEH &amp;&amp; TLS"></a>VEH &amp;&amp; TLS</h4><p>查看IDA的Exports窗口可以看到TlsCallback_0_0</p><blockquote><p>TLS，Thread Local Storage 线程局部存储，TLS回调函数的调用运行要先于PE代码执行，该特性使它可以作为一种反调试技术使用。</p><p>TLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据。</p></blockquote><p>return了一个奇怪的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID __stdcall <span class="title">TlsCallback_0_0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">return</span> AddVectoredExceptionHandler(<span class="number">1u</span>, Handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attributes: thunk</span></span><br><span class="line"><span class="function">LONG __stdcall <span class="title">Handler</span><span class="params">(struct _EXCEPTION_POINTERS *ExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_411BD0(ExceptionInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">sub_411BD0</span><span class="params">(_EXCEPTION_POINTERS *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h]</span></span><br><span class="line">  DWORD v4; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a1-&gt;ExceptionRecord-&gt;ExceptionCode != <span class="number">0xC0000005</span> ) <span class="comment">// 不可访问地址相应的异常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v4 = a1-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>;</span><br><span class="line">  v3[<span class="number">0</span>] = <span class="number">16</span>;</span><br><span class="line">  v3[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">  v3[<span class="number">2</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">  v3[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">  v3[<span class="number">6</span>] = <span class="number">4</span>;</span><br><span class="line">  v3[<span class="number">7</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">8</span>] = <span class="number">11</span>;</span><br><span class="line">  v3[<span class="number">9</span>] = <span class="number">5</span>;</span><br><span class="line">  v3[<span class="number">10</span>] = <span class="number">31</span>;</span><br><span class="line">  v3[<span class="number">11</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">12</span>] = <span class="number">33</span>;</span><br><span class="line">  v3[<span class="number">13</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">14</span>] = <span class="number">72</span>;</span><br><span class="line">  v3[<span class="number">15</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">16</span>] = <span class="number">6</span>;</span><br><span class="line">  v3[<span class="number">17</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">18</span>] = <span class="number">17</span>;</span><br><span class="line">  v3[<span class="number">19</span>] = <span class="number">69</span>;</span><br><span class="line">  v3[<span class="number">20</span>] = <span class="number">5</span>;</span><br><span class="line">  v3[<span class="number">21</span>] = <span class="number">62</span>;</span><br><span class="line">  v3[<span class="number">22</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">23</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">24</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">25</span>] = <span class="number">72</span>;</span><br><span class="line">  v3[<span class="number">26</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">27</span>] = <span class="number">69</span>;</span><br><span class="line">  v3[<span class="number">28</span>] = <span class="number">33</span>;</span><br><span class="line">  v3[<span class="number">29</span>] = <span class="number">31</span>;</span><br><span class="line">  v3[<span class="number">30</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v3[i] != (((*(<span class="keyword">char</span> *)(v4 + <span class="number">2</span> * i) ^ <span class="number">0x37</span>) + <span class="number">4</span>) ^ <span class="number">0x42</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a1-&gt;ContextRecord-&gt;Eip += <span class="number">66</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a1-&gt;ContextRecord-&gt;Eip += <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Handler显然是第二段解密），因为我实在是太菜了，又查了一下这个函数的功能，发现了另一个异常处理机制VEH</p><p>VEH处理流程</p><blockquote><ul><li>CPU捕获异常信息</li><li>通过KiDispatchException进行分发(EIP=KiUserExceptionDispatcher)</li><li>KiUserExceptionDispatcher调用RtIDispatchException.</li><li>RtIDispatchException查找VEH处理函数链表并调用相关处理函数</li><li>代码返回到KiUserExceptionDispatcher</li><li>调用ZwContinue再次进入0环(ZwContinue调用NtContinue,主要作用就是恢复 TRAPFRAME然后通过_KiServiceExit返回到3环)。</li><li>线程再次返回3环后,从修正后的位置开始执行</li></ul><p>学习自：<a href="https://blog.csdn.net/weixin_42052102/article/details/83540134">https://blog.csdn.net/weixin_42052102/article/details/83540134</a></p></blockquote><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p><strong>这样一来整个流程大致明了了</strong></p><ul><li>VEH抓到<code>0xC0000005</code></li><li>SEH抓到<code>0xC0000094</code></li><li>分别的flag在各自的handler里面</li></ul><p>脚本如下，写的比较乱</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> errr_addr = <span class="number">0x30234B</span>;</span><br><span class="line">    <span class="keyword">char</span> magic_1[] = <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_1[i] ^ 0x13 ^ errr_addr)+4)^0x4d);</span></span><br><span class="line">        flag[<span class="number">2</span> * i + <span class="number">1</span>] = ((magic_1[i] ^ <span class="number">0x13</span> ^ errr_addr)+<span class="number">4</span>)^<span class="number">0x4d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> magic_2[] = &#123;<span class="number">16</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">4</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">31</span>,<span class="number">46</span>,<span class="number">33</span>,<span class="number">46</span>,<span class="number">72</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">17</span>,<span class="number">69</span>,<span class="number">5</span>,<span class="number">62</span>,<span class="number">46</span>,<span class="number">24</span>,<span class="number">21</span>,<span class="number">72</span>,<span class="number">46</span>,<span class="number">69</span>,<span class="number">33</span>,<span class="number">31</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_2[i]^0x42)-4)^0x37);</span></span><br><span class="line">        flag[<span class="number">2</span> * i] = ((magic_2[i]^<span class="number">0x42</span>)<span class="number">-4</span>)^<span class="number">0x37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    <span class="comment">// miniLctf&#123;y0u_a1r4ady_und4rstand_th4_w1nd0ws_exc4pt1On_handl1e_m4chan1sm&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sub-track"><a href="#sub-track" class="headerlink" title="sub | track"></a>sub | track</h3><blockquote><p>傀儡进程</p></blockquote><h4 id="Pre-check"><a href="#Pre-check" class="headerlink" title="Pre_check"></a>Pre_check</h4><p>这题居然让我电脑报毒了，让我康康！（康不懂，爬了</p><p>main函数很混乱，但仔细看能看出一点东西，貌似是创建一个进程，尝试把另一个文件读进来，然后开始执行？还看见一个熟悉的SMC</p><p>看了hint之后搜到了傀儡进程，一个最基本傀儡进程的实现如下</p><ul><li>CreateProcess创建进程，传入参数CREATE_SUSPENDED使进程挂起</li><li>NtUnmapViewOfSection清空新进程的内存数据</li><li>VirtualAllocEx申请新的内存</li><li>WriteProcessMemory向内存写入payload</li><li>SetThreadContext设置入口点</li><li>ResumeThread唤醒进程，执行payload</li></ul><h4 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h4><p>emmm直接调的话，由于各种奇怪的反调试，好像没法成功，于是我打开了010editor，直接把傀儡进程在运行前全都异或回去，并dump出来单独分析</p><p>清晰的main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main_0</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> input_len; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+0h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [esp+0h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">char</span> input[<span class="number">56</span>]; <span class="comment">// [esp+D0h] [ebp-3Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_40C015);</span><br><span class="line">  <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0x32</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input your flag: &quot;</span>, v5);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="keyword">char</span>)input);</span><br><span class="line">  input_len = <span class="built_in">strlen</span>(input);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)off_40A040(input, input_len) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulation~~~&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Try again~~~&quot;</span>, v6);</span><br><span class="line">  getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>off_40A040</code>一路往下点，就看到加密逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> __cdecl <span class="title">sub_4014F0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+DCh] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_40C015);</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">char</span>)(((*(_BYTE *)(i + a1) ^ <span class="number">0x66</span>) + <span class="number">4</span>) ^ <span class="number">0x55</span>) != byte_40A020[i] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺常规的，直接还原？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic_1 = [<span class="number">0x5A</span>,<span class="number">0x46</span>,<span class="number">0x59</span>,<span class="number">0x46</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x74</span>,<span class="number">0x63</span>,<span class="number">0x47</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x43</span>,<span class="number">0x47</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x5E</span>,<span class="number">0x44</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_1)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(((magic_1[i] ^ <span class="number">0x55</span>) -<span class="number">4</span>) ^ <span class="number">0x66</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># miniLctf&#123;Th1s_1s_th4_fak4_f1ag!&#125;</span></span><br></pre></td></tr></table></figure><p>我aklsjdaiwjdawijdaiwdjqw（</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><p>又是上一题一样的，在Exports里面有<code>TlsCallback_0_0</code></p><p>里面有对于<code>off_40A040</code>的指向进行处理，然后就没啥问题了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic_1 = [<span class="number">0x5A</span>,<span class="number">0x46</span>,<span class="number">0x59</span>,<span class="number">0x46</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x74</span>,<span class="number">0x63</span>,<span class="number">0x47</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x43</span>,<span class="number">0x47</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x5E</span>,<span class="number">0x44</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">fake_flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_1)):</span><br><span class="line">    fake_flag += <span class="built_in">chr</span>(((magic_1[i] ^ <span class="number">0x55</span>) -<span class="number">4</span>) ^ <span class="number">0x66</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_flag)</span><br><span class="line"></span><br><span class="line">magic_2=[<span class="number">0x5A</span>,<span class="number">0x26</span>,<span class="number">0x59</span>,<span class="number">0x26</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x54</span>,<span class="number">0x6D</span>,<span class="number">0x52</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x4C</span>,<span class="number">0x0F</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x43</span>,<span class="number">0x03</span>,<span class="number">0x4D</span>,<span class="number">0x03</span>,<span class="number">0x4C</span>,<span class="number">0x43</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_2)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(((magic_2[i] ^ <span class="number">0x66</span>) - <span class="number">4</span>) ^ <span class="number">0x55</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1><p>还是太菜了，虽然是校内rk3，但这分数太惨了，加油加油！</p>]]></content>
      
      
      <categories>
          
          <category> CTF-Competition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-01】NPUCTF2020-BabyObfuscation</title>
      <link href="2021/04/21/eec6d01d64db/"/>
      <url>2021/04/21/eec6d01d64db/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-1-查壳"><a href="#Step-1-查壳" class="headerlink" title="Step 1: 查壳"></a>Step 1: 查壳</h1><ol><li>发现是64位程序，无壳</li><li>运行程序提示为”WHERE IS MY KEY!?”</li></ol><h1 id="Step-2-IDA加载初步判断功能"><a href="#Step-2-IDA加载初步判断功能" class="headerlink" title="Step 2: IDA加载初步判断功能"></a>Step 2: IDA加载初步判断功能</h1><p><code>main</code>函数直接F5看的话，是这样一坨浆糊</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">bool</span> v18; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v22; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v26; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v28[<span class="number">68</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> Str[<span class="number">1008</span>]; <span class="comment">// [rsp+130h] [rbp+B0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v30[<span class="number">1008</span>]; <span class="comment">// [rsp+520h] [rbp+4A0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v31[<span class="number">4</span>]; <span class="comment">// [rsp+14E0h] [rbp+1460h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+14F0h] [rbp+1470h]</span></span><br><span class="line">  <span class="keyword">int</span> k; <span class="comment">// [rsp+14F4h] [rbp+1474h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+14F8h] [rbp+1478h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14FCh] [rbp+147Ch]</span></span><br><span class="line"></span><br><span class="line">  _main(argc, argv, envp);</span><br><span class="line">  <span class="built_in">memset</span>(v30, <span class="number">0</span>, <span class="number">0xFA0</span>ui64);</span><br><span class="line">  v30[<span class="number">1000</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v28, <span class="number">0</span>, <span class="number">0x100</span>ui64);</span><br><span class="line">  v28[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">64</span>; ++i )</span><br><span class="line">    v28[i] = i + <span class="number">1</span>;</span><br><span class="line">  v31[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  v31[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">  v31[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">  v31[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">  v30[<span class="number">1004</span>] = <span class="number">2</span>;</span><br><span class="line">  v30[<span class="number">1005</span>] = <span class="number">3</span>;</span><br><span class="line">  v30[<span class="number">1006</span>] = <span class="number">4</span>;</span><br><span class="line">  v30[<span class="number">1007</span>] = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;WHERE IS MY KEY!?&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%32s&quot;</span>, Str);</span><br><span class="line">  v32 = <span class="built_in">strlen</span>(Str);</span><br><span class="line">  v3 = F0X1(v28[j], v28[j]);</span><br><span class="line">  <span class="keyword">for</span> ( j = v3 / v28[j]; j &lt;= v32; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (v28[j] + v28[j + <span class="number">1</span>]) * (v28[j] + v28[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt;= (<span class="keyword">int</span>)(F0X5(<span class="number">2</span>, <span class="number">2</span>) * v28[j] * v28[j + <span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = ~Str[(<span class="keyword">int</span>)F0X4(j, <span class="number">1</span>)];</span><br><span class="line">      v6 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] = ~(v5 + v31[v6 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = F0X1(v28[j], v28[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; (<span class="keyword">int</span>)F0X1(v28[j + <span class="number">1</span>], ~(~v28[j + <span class="number">1</span>] + v28[j])) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v30[j];</span><br><span class="line">      v9 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] = ~(~v8 + v28[v9 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]) * v8;</span><br><span class="line">    &#125;</span><br><span class="line">    v10 = v28[j + <span class="number">1</span>];</span><br><span class="line">    v11 = F0X5(<span class="number">2</span>, <span class="number">1</span>) * v10;</span><br><span class="line">    v12 = v28[j];</span><br><span class="line">    v13 = F0X5(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    v14 = F0X1(v12 * v13, v11);</span><br><span class="line">    v15 = F0X5(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v14 == v15 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X1(v28[j], v28[j + <span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] ^= v31[v16 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = F0X5(V0X3, v28[j]);</span><br><span class="line">    v18 = v17 &lt; v28[j] + <span class="number">1</span>;</span><br><span class="line">    v19 = F0X5(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)F0X3(v19 &gt;= j, v18) )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = ~Str[(<span class="keyword">int</span>)F0X4(j, <span class="number">1</span>)];</span><br><span class="line">      v21 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] ^= ~(v20 + v31[v21 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    v22 = F0X5(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    v23 = F0X1(v28[j], v28[j]);</span><br><span class="line">    v30[j] *= v22 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X5(<span class="number">2</span>, v23 / v28[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  v24 = F0X5(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X4(v24, <span class="number">1</span>) != v32 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  v25 = F0X1(v28[k], v28[k]);</span><br><span class="line">  <span class="keyword">for</span> ( k = v25 / v28[k]; k &lt;= v32; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    v26 = v30[k];</span><br><span class="line">    <span class="keyword">if</span> ( v26 == (<span class="keyword">int</span>)F0X4(A0X6[k], <span class="number">1</span>) / <span class="number">10</span> )</span><br><span class="line">      ++V0X2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( V0X2 == v32 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nPASS&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_23:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nDENIED&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看<code>F0X1</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">    result = F0X1(a2, (<span class="keyword">int</span>)a1 % a2);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = a1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个递归函数容易发现是在求a1和a2的最大公因数gcd</p><p>然后是<code>F0X5</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X5</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (a2 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      v4 *= a1;</span><br><span class="line">    a1 *= a1;</span><br><span class="line">    a2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也比较容易看出来，就是在求a1的a2次方pow</p><p>接着是<code>F0X4</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X4</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)~(~a1 + a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于两个int而言，这个结构等价于a1-a2</p><p>继续看<code>F0X3</code>和<code>F0X2</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall F0X3(bool a1, bool a2)</span><br><span class="line">&#123;</span><br><span class="line">  char v2; &#x2F;&#x2F; bl</span><br><span class="line">  char v3; &#x2F;&#x2F; al</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; F0X2(a2, a2);</span><br><span class="line">  v3 &#x3D; F0X2(a1, a1);</span><br><span class="line">  return F0X2(v3, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_BOOL8 __fastcall F0X2(char a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  return a1 &#x3D;&#x3D; a2 &amp;&amp; a1 !&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个需要稍微推导一下，可以看出等价于a1&amp;a2</p><blockquote><p>对于函数的功能，可以考虑复制下来，然后测试一下，再结合推导，就能比较容易的判断出函数的功能了</p></blockquote><p>于是进行重命名</p><p><img src="https://i.loli.net/2021/04/21/lneU2O8a6YhrpVC.png" alt="p1.png"></p><h1 id="Step-3-判断条件跳转"><a href="#Step-3-判断条件跳转" class="headerlink" title="Step 3: 判断条件跳转"></a>Step 3: 判断条件跳转</h1><ul><li><p>第一处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v4 = (v28[j] + v28[j + <span class="number">1</span>]) * (v28[j] + v28[j + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ( v4 &gt;= (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2</span>) * v28[j] * v28[j + <span class="number">1</span>]) )</span><br></pre></td></tr></table></figure><p>抽象出来即</p><script type="math/tex; mode=display">(x + y) ^ 2 \ge 4xy</script><p>这是永真的，也就是下面的代码块永远会被执行</p></li><li><p>第二处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v7 = gcd(v28[j], v28[j + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ( v7 &gt; (<span class="keyword">int</span>)gcd(v28[j + <span class="number">1</span>], ~(~v28[j + <span class="number">1</span>] + v28[j])) )</span><br></pre></td></tr></table></figure><p>等价于</p><script type="math/tex; mode=display">gcd(x, y) > gcd(y, x-y)</script><p>左右两边显然是一样的，所以下面的代码块不可能执行</p></li><li><p>第三处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v10 = v28[j + <span class="number">1</span>];</span><br><span class="line">v11 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>) * v10;</span><br><span class="line">v12 = v28[j];</span><br><span class="line">v13 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">v14 = gcd(v12 * v13, v11);</span><br><span class="line">v15 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ( v14 == v15 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)gcd(v28[j], v28[j + <span class="number">1</span>]) )</span><br></pre></td></tr></table></figure><p>等价于</p><script type="math/tex; mode=display">gcd(2x, 2y) = 2gcd(x, y)</script><p>这也是永真的，故下面的代码块一定执行</p></li><li><p>第四处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v17 = <span class="built_in">pow</span>(V0X3, v28[j]);</span><br><span class="line">v18 = v17 &lt; v28[j] + <span class="number">1</span>;</span><br><span class="line">v19 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)AND(v19 &gt;= j, v18) )</span><br><span class="line"><span class="comment">//其中V0X3 == 3</span></span><br><span class="line"><span class="comment">//这里需要看看后面关于整个key长度的判断，这里就不说明了</span></span><br></pre></td></tr></table></figure><p>key长度是15故<code>v19 &gt;= j</code>必定成立</p><p>于是只需判断</p><script type="math/tex; mode=display">f(x)=3^x - x - 1 <0</script><p>求导或者直接画图都能判断出该条件为假，则下面的代码块不会执行</p></li><li><p><strong>综上</strong></p><p>只有三处代码有效</p><p><img src="https://i.loli.net/2021/04/21/i19yFkjOEmha56R.png" alt="p2.png"></p></li></ul><p>最终是这样的效果</p><h1 id="Step-4-exp"><a href="#Step-4-exp" class="headerlink" title="Step 4: exp"></a>Step 4: exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enc = [<span class="number">780</span>, <span class="number">780</span>, <span class="number">850</span>, <span class="number">590</span>, <span class="number">800</span>, <span class="number">640</span>, <span class="number">1150</span>, <span class="number">460</span>, <span class="number">980</span>, <span class="number">960</span>, <span class="number">1170</span>, <span class="number">530</span>, <span class="number">970</span>, <span class="number">1080</span>, <span class="number">1250</span>]</span><br><span class="line">vec = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i] = enc[i] // <span class="number">10</span>;</span><br><span class="line">    enc[i] ^= vec[i%<span class="number">4</span>]</span><br><span class="line">    enc[i] += vec[i%<span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc[i]), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1>]]></content>
      
      
      <categories>
          
          <category> CTF-Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
            <tag> BUUOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>whoami</title>
      <link href="2021/04/14/2390e06bacb2/"/>
      <url>2021/04/14/2390e06bacb2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">track</span><br></pre></td></tr></table></figure><p>来自XDSEC的大一逆向工程菜鸡</p><p>正努力追赶带佬们的脚步</p>]]></content>
      
      
      
        <tags>
            
            <tag> 简介 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
