<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【NOTES-04】Go Tour</title>
      <link href="2021/06/10/84c9748611d2/"/>
      <url>2021/06/10/84c9748611d2/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Syntax"><a href="#Basic-Syntax" class="headerlink" title="Basic Syntax"></a>Basic Syntax</h2><p>关于为什么声明变量时要和C有所区别，参见这篇文章<a href="https://blog.go-zh.org/gos-declaration-syntax">Go’s Declaration Syntax</a></p><h2 id="Basic-Type"><a href="#Basic-Type" class="headerlink" title="Basic Type"></a>Basic Type</h2><p>Go 的基本类型有</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">    <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p><h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p><p>零值是：</p><ul><li>数值类型为 <code>0</code>，</li><li>布尔类型为 <code>false</code>，</li><li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li></ul><h2 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h2><p>一个在全局声明的数值常量由上下文决定其类型</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;rxyyds&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p><p>该语句声明的变量作用域仅在 <code>if</code> 之内。</p><p><strong>但是</strong>，在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。</p><p><strong>除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。</strong></p><p>Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。（这一个特性非常关键，使得switch的使用频率会大大增加）</p><p>没有条件的 switch 同 <code>switch true</code> 一样。（就类似于<code>for</code>不写条件得到一个无限循环）</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><h3 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h3><p>defer 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><h3 id="defer栈"><a href="#defer栈" class="headerlink" title="defer栈"></a>defer栈</h3><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">counting</span><br><span class="line">done</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="defer-panic-and-recover"><a href="#defer-panic-and-recover" class="headerlink" title="defer-panic-and-recover"></a>defer-panic-and-recover</h3><p>看看这个吧！<a href="[Defer, Panic, and Recover - Go 语言博客 (go-zh.org">defer-panic-recover</a>](<a href="https://blog.go-zh.org/defer-panic-and-recover">https://blog.go-zh.org/defer-panic-and-recover</a>))</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered in f&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Calling g.&quot;</span>)</span><br><span class="line">    g(<span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from g.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Panicking!&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer in g&quot;</span>, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Printing in g&quot;</span>, i)</span><br><span class="line">    g(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Calling g.</span><br><span class="line">Printing in g 0</span><br><span class="line">Printing in g 1</span><br><span class="line">Printing in g 2</span><br><span class="line">Printing in g 3</span><br><span class="line">Panicking!</span><br><span class="line">Defer in g 3</span><br><span class="line">Defer in g 2</span><br><span class="line">Defer in g 1</span><br><span class="line">Defer in g 0</span><br><span class="line">panic: 4</span><br><span class="line"> </span><br><span class="line">panic PC&#x3D;0x2a9cd8</span><br><span class="line">[stack trace omitted]</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go 拥有指针。指针保存了值的内存地址。</p><p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。<strong>其零值为 <code>nil</code>。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p *int</span><br></pre></td></tr></table></figure><p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i :&#x3D; 42</span><br><span class="line">p &#x3D; &amp;i</span><br></pre></td></tr></table></figure><p><code>*</code> 操作符表示指针指向的底层值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(*p) &#x2F;&#x2F; 通过指针 p 读取 i</span><br><span class="line">*p &#x3D; 21         &#x2F;&#x2F; 通过指针 p 设置 i</span><br></pre></td></tr></table></figure><p>这也就是通常所说的“间接引用”或“重定向”。</p><p><strong>与 C 不同，Go 没有指针运算。</strong></p><p>例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">p := &amp;i         <span class="comment">// 指向 i</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// 通过指针读取 i 的值</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针设置 i 的值</span></span><br><span class="line">fmt.Println(i)  <span class="comment">// 查看 i 的值</span></span><br><span class="line"></span><br><span class="line">p = &amp;j         <span class="comment">// 指向 j</span></span><br><span class="line">*p = *p / <span class="number">37</span>   <span class="comment">// 通过指针对 j 进行除法运算</span></span><br><span class="line">fmt.Println(j) <span class="comment">// 查看 j 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">42</span><br><span class="line">21</span><br><span class="line">73</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>用一个例子来说明</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;) <span class="comment">// 大括号来初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体字段可以通过<strong>点号</strong>来访问，也可以通过<strong>结构体指针</strong>来访问。</p><p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用<strong>隐式间接</strong>引用，直接写 <code>p.X</code> 就可以。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>Goroutine是一个协程，它与所处的函数是分开运行的，并且具有背后运行机制。即如果它所处的函数已经结束运行，不管还有多少Goroutine没有结束，都会被终止运行</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">count(<span class="number">5</span>, <span class="string">&quot;ysh&quot;</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">count(<span class="number">3</span>, <span class="string">&quot;bobo&quot;</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(n <span class="keyword">int</span>, baby <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">fmt.Println(i+<span class="number">1</span>, baby)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><h4 id="一般语言——内存共享来交流"><a href="#一般语言——内存共享来交流" class="headerlink" title="一般语言——内存共享来交流"></a>一般语言——内存共享来交流</h4><p>通常一个具有多线程能力的编程语言都需要线程之间进行交流，而一般是通过共享内存来交流，即各个线程共同操纵同一片内存区域，并且开发者为了避免同时操纵内存造成的错误，还发明了线程锁，包括最简单的自旋锁。</p><h4 id="Golang——交流来共享内存"><a href="#Golang——交流来共享内存" class="headerlink" title="Golang——交流来共享内存"></a>Golang——交流来共享内存</h4><p>go语言并不是这么操作的，它是通过线程间的一个channel来交流，（可以简单把它理解为自带的一个锁），这就表现为：</p><p><strong>发送一条消息，代码被阻塞，直到有人收听；收听一条消息，代码被阻塞，直到有人发送</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> count(<span class="number">5</span>, <span class="string">&quot;hs&quot;</span>, c)</span><br><span class="line">    <span class="keyword">for</span> message := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(n <span class="keyword">int</span>, animal <span class="keyword">string</span>, c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- animal</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于range可以查看这个：<a href="[Range · golang/go Wiki (github.com">range</a>](<a href="https://github.com/golang/go/wiki/Range">https://github.com/golang/go/wiki/Range</a>))</p><h4 id="如何管理多个channel？"><a href="#如何管理多个channel？" class="headerlink" title="如何管理多个channel？"></a>如何管理多个channel？</h4><p>首先说一下为什么要涉及这个问题，你可能会觉得我难道不能写一个循环，先接收一条消息，再接收一条消息吗？确实，你确实可以，但这么做的代价也很容易想到——<strong>因为channel的阻塞特性，如果两个线程的运行时间相差非常大的话，就会造成非常严重的时间损耗</strong></p><p>我们可以使用select语句，它会在我们提前给定好的channel中选择没有被阻塞的来运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c1 :&#x3D; make(chan string)</span><br><span class="line">c2 :&#x3D; make(chan string)</span><br><span class="line">go func() &#123;</span><br><span class="line">c1 &lt;- &quot;hs&quot;</span><br><span class="line">time.Sleep(time.Millisecond * 500)</span><br><span class="line">&#125;()</span><br><span class="line">go func() &#123;</span><br><span class="line">c2 &lt;- &quot;dbt&quot;</span><br><span class="line">time.Sleep(time.Millisecond * 2000)</span><br><span class="line">&#125;()</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case msg :&#x3D; &lt;- c1:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">case msg :&#x3D; &lt;- c2:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的正确使用姿势"><a href="#map的正确使用姿势" class="headerlink" title="map的正确使用姿势"></a>map的正确使用姿势</h2><p>直接查看<a href="[10 Golang map的正确使用姿势 - 简书 (jianshu.com">map</a>](<a href="https://www.jianshu.com/p/726688f6539c">https://www.jianshu.com/p/726688f6539c</a>))</p><h2 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h2><p>参考<a href="[09 Golang sort排序 - 简书 (jianshu.com">sort</a>](<a href="https://www.jianshu.com/p/f79aaf39ded8">https://www.jianshu.com/p/f79aaf39ded8</a>))</p><h2 id="slice切片"><a href="#slice切片" class="headerlink" title="slice切片"></a>slice切片</h2><p>参考<a href="[08 Golang引用类型——切片 - 简书 (jianshu.com">slice</a>](<a href="https://www.jianshu.com/p/ca4891ad6e4f">https://www.jianshu.com/p/ca4891ad6e4f</a>))</p><h2 id="range用法"><a href="#range用法" class="headerlink" title="range用法"></a>range用法</h2><p>参考<a href="[Range · golang/go Wiki (github.com">range</a>](<a href="https://github.com/golang/go/wiki/Range">https://github.com/golang/go/wiki/Range</a>))</p>]]></content>
      
      
      <categories>
          
          <category> Programs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
            <tag> Notes </tag>
            
            <tag> Golang </tag>
            
            <tag> Programs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-03】MiniL-CTF-2021-chip</title>
      <link href="2021/05/23/d92b1de35ade/"/>
      <url>2021/05/23/d92b1de35ade/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CTF-Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Reverse </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOTES-03】StreamCipher-线性反馈移位寄存器</title>
      <link href="2021/05/22/1fbd3db05dc3/"/>
      <url>2021/05/22/1fbd3db05dc3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>接着上一篇往下，该写LFSR(linear feedback shift register)了</p></blockquote><h1 id="什么是线性反馈移位寄存器"><a href="#什么是线性反馈移位寄存器" class="headerlink" title="什么是线性反馈移位寄存器"></a>什么是线性反馈移位寄存器</h1><p>我先递归学习了几个数学概念</p><h2 id="母函数（生成函数）"><a href="#母函数（生成函数）" class="headerlink" title="母函数（生成函数）"></a>母函数（生成函数）</h2><h3 id="普通型母函数"><a href="#普通型母函数" class="headerlink" title="普通型母函数"></a>普通型母函数</h3><p><strong>定义</strong>：</p><p>对于任意一个数列$a_0,a_1,a_2\cdots a_n$，用它的每一项可以定义一个函数：</p><script type="math/tex; mode=display">G(x)=a_0+a_1x+a_2x^2+\cdots +a_nx^n</script><p>则G(x)是数列的生成函数，或者更准确地说，是一个<strong>无穷级数</strong></p><blockquote><p>虽然说是一个无穷级数，但我们可以设置$j&gt;n$时，$a_j=0$之类的，使得G(x)成为一个n次多项式，但又是一个无穷序列（doge</p></blockquote><p>更数学一点的表示形式如下：</p><script type="math/tex; mode=display">G(a_n;x)=\Sigma_{n=0}^\infty a_nx^n</script><h3 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h3><p>一般形式为：</p><script type="math/tex; mode=display">EG(a_n;x)=\Sigma_{n=0}^\infty a_n\frac{x^n}{n!}</script><h2 id="有限数域上的LFSR"><a href="#有限数域上的LFSR" class="headerlink" title="有限数域上的LFSR"></a>有限数域上的LFSR</h2><blockquote><p>有限数域一般是gf(2)，即只含有0, 1两个数</p></blockquote><h3 id="说明与定义"><a href="#说明与定义" class="headerlink" title="说明与定义"></a>说明与定义</h3><ul><li>移位寄存器主要功能是产生密钥流</li><li>gf(2)表示存储器为二元存储器，只能取0或1</li><li>n级表示n个存储器</li><li>线性表示反馈函数$f(a1,a2,…,an)$为线性函数,运算有与或非，与反馈移位寄存器的状态有关，状态有$2^n$种</li><li>初始状态由用户决定</li></ul><p><img src="https://ctf-wiki.org/crypto/streamcipher/fsr/figure/n-fsr.png" alt="n-fsr.png (934×244) (ctf-wiki.org)"></p><div align="center">图1</div><p><img src="https://img-blog.csdnimg.cn/20200717222000117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjczMzQ0Mg==,size_16,color_FFFFFF,t_70" alt="20200717222000117.png (1151×555) (csdnimg.cn)"></p><div align="center">图2</div><p>可作递推模拟如下：</p><script type="math/tex; mode=display">a_{n+t}=c_1a_{n+t-1}\bigoplus c_2a_{n+t-2}\bigoplus\cdots \bigoplus c_na_{t}, t=1,2,\cdots</script><p><strong>让我们看一个3级的例子</strong></p><p><img src="https://img-blog.csdnimg.cn/20200717223543874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjczMzQ0Mg==,size_16,color_FFFFFF,t_70" alt="20200717223543874.png (1226×421) (csdnimg.cn)"></p><p>定义初始状态为</p><div class="table-container"><table><thead><tr><th style="text-align:center">$a_1$</th><th style="text-align:center">$a_2$</th><th style="text-align:center">$a_3$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><p>则$a_4=a_1\bigoplus a_3=0$，然后流出一个$a_1$，3个寄存器变为</p><pre class="mermaid">graph LR    a4-->a3-->a2</pre><p>反馈函数变为$f(a_2,a_3,a_4)=a_2\bigoplus a_4$</p><p>反复进行几轮上述操作，就可以得到输出序列，以及周期</p><h3 id="LFSR输出序列的性质"><a href="#LFSR输出序列的性质" class="headerlink" title="LFSR输出序列的性质"></a>LFSR输出序列的性质</h3><p>线性反馈移位寄存器实现起来简单，速度快，而且有较为成功的理论，成为构造密钥流生成器的最重要的部件之一。<br>我们总是假定$c_1,c_2,…,c_n$中至少有一个不为0，否则$f(a1,a2,…,an)=0$，总是假定$c_n=1$。</p><ul><li>$n级LFSR状态数：最多有2^n个$</li><li>$n级LFSR的状态周期：\leq2^n-1$</li><li>$输出序列的周期=状态周期\leq2^n-1$</li><li>$选择合适的反馈函数可使序列的周期达到最大值2^n-1，周期达到最大值的序列称为m序列。$</li></ul><h3 id="数学推导与算法"><a href="#数学推导与算法" class="headerlink" title="数学推导与算法"></a>数学推导与算法</h3><blockquote><p>摘自<a href="https://ctf-wiki.org">CTFwiki</a></p></blockquote><p>线性反馈移位寄存器的反馈函数一般如下</p><script type="math/tex; mode=display">a_{i+n} = \Sigma_{j=1}^n c_ja_{i+n-j} \tag{1}</script><p>其中，$c_j$均在某个有限域 $F_q$ 中。</p><p>进而，可以求得其<strong>特征多项式</strong>为</p><script type="math/tex; mode=display">f(x)=x^n-\Sigma_{i=1}^n c_ix^{n-i} \tag{2}</script><blockquote><p>通过线性变换得到，由于还没学，就先随便写写啦hhh</p><script type="math/tex; mode=display">\left[\begin{matrix}a_{i+1},a_{i+2},a_{i+3},\cdots,a_{i+n}\end{matrix}\right] \\=\left[\begin{matrix}a_{i+1},a_{i+2},a_{i+3},\cdots,a_{i+n}\end{matrix}\right]\left[\begin{matrix}0 & 0 & \cdots & 0 & c_n\\1 & 0 & \cdots & 0 & c_{n-1}\\0 & 1 & \cdots & 0 & c_{n-2}\\\vdots& \vdots &\ddots&\vdots\\0 & 0 & \cdots & 1 & c_1\end{matrix}\right]\\=\left[\begin{matrix}a_{0},a_{1},a_{2},\cdots,a_{n-1}\end{matrix}\right]\left[\begin{matrix}0 & 0 & \cdots & 0 & c_n\\1 & 0 & \cdots & 0 & c_{n-1}\\0 & 1 & \cdots & 0 & c_{n-2}\\\vdots& \vdots &\ddots&\vdots\\0 & 0 & \cdots & 1 & c_1\end{matrix}\right]^{i+1}</script></blockquote><p>同时，定义其<strong>互反多项式</strong>为</p><script type="math/tex; mode=display">\bar f(x) = x^nf(\frac 1 x) = 1 - \Sigma_{i=1}^n c_ix^i</script><p>也称互反多项式为线性反馈移位寄存器的联结多项式。</p><h3 id="特征多项式与生成函数"><a href="#特征多项式与生成函数" class="headerlink" title="特征多项式与生成函数"></a>特征多项式与生成函数</h3><p>已知某个 n 级线性反馈移位寄存器的特征多项式，那么该序列对应的生成函数为</p><script type="math/tex; mode=display">A(x) = \frac {p(x)} {\bar f(x)}</script><p>其中$p(x) = \Sigma_{i=1}^n(c_{n-i}x^{n-i}\Sigma_{j=1}^ia_jx^{j-1})$。可以看出 $p(x) $完全由初始状态和反馈函数的系数决定。</p><h3 id="序列周期与生成函数"><a href="#序列周期与生成函数" class="headerlink" title="序列周期与生成函数"></a>序列周期与生成函数</h3><p>序列的的周期为其生成函数的既约真分式的分母的周期。</p><p>对于 n 级线性反馈移位寄存器，最长周期为 $2^n−1$（排除全零）。达到最长周期的序列一般称为 m 序列。</p><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><ul><li>将两个序列累加得到新的序列的周期为这两个序列的周期的和。</li><li>序列是 n 级 m 序列，当且仅当序列的极小多项式是 n 次本原多项式。</li></ul><h3 id="B-M-算法"><a href="#B-M-算法" class="headerlink" title="B-M 算法"></a>B-M 算法</h3><p>一般来说，我们可以从两种角度来考虑 LFSR</p><ul><li>密钥生成角度，一般我们希望使用<strong>级数尽可能低</strong>的 LFSR 来生成周期大，随机性好的序列。</li><li>密码分析角度，给定一个长度为 n 的序列 a，如何<strong>构造一个级数尽可能小</strong>的 LFSR 来生成它。其实这就是 B-M 算法的来源。</li></ul><p>一般来说，我们定义一个序列的线性复杂度如下</p><ul><li>若 s 为一个全零序列，则线性复杂度为 0。</li><li>若没有 LFSR 能生成 s，则线性复杂度为无穷。</li><li>否则，s 的线性复杂度为生成 L(s) 的最小级的 LFSR。</li></ul><p>BM 算法的要求我们需要知道长度为 2n 的序列。其复杂度</p><ul><li>时间复杂度：$O(n^2)$ 次比特操作</li><li>空间复杂度：$O(n) $比特。</li></ul><p>关于 BM 算法的细节，后续添加，目前处于学习过程中。</p><p>但是其实如果我们知道了长度为 2n 的序列，我们也可以一种比较笨的方法来获取原先的序列。不妨假设已知的序列为$a_1,…,a_{2n}$，我们可以令</p><script type="math/tex; mode=display">S_1=(a_1,...,a_n)\\S_2=(a_2,...,a_{n+1})\\....\\S_{n+1}=(a_{n+1},...,a_{2n})</script><p>那么我们可以构造矩阵$ X=(S_1,…,S_n)$，那么</p><p>$S_{n+1}=(c_n,…,c_1)X$</p><p>所以$(c_n,…,c_1)=S_{n+1}X^{−1}$</p><p>进而我们也就知道了 LFSR 的反馈表达式，进而我们就可以推出初始化种子。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="2018-CISCN-初赛-oldstreamgame"><a href="#2018-CISCN-初赛-oldstreamgame" class="headerlink" title="2018 CISCN 初赛 oldstreamgame"></a>2018 CISCN 初赛 oldstreamgame</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&quot;flag&#123;xxxxxxxxxxxxxxxx&#125;&quot;</span></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">&quot;flag&#123;&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> flag.endswith(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag)==<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span>(<span class="params">R,mask</span>):</span></span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span> <span class="comment"># R&lt;&lt;1，取低32位，最后一位是0</span></span><br><span class="line">    i=(R&amp;mask)&amp;<span class="number">0xffffffff</span> <span class="comment"># R和mask与一下</span></span><br><span class="line">    lastbit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">        lastbit^=(i&amp;<span class="number">1</span>) <span class="comment"># i由最后一位逐位向最高位异或，存在lastbit中，lastbit只有1个bit</span></span><br><span class="line">        i=i&gt;&gt;<span class="number">1</span></span><br><span class="line">    output^=lastbit <span class="comment"># out的最后一位变成lastbit，其它不变</span></span><br><span class="line">    <span class="keyword">return</span> (output,lastbit)</span><br><span class="line"></span><br><span class="line">R=<span class="built_in">int</span>(flag[<span class="number">5</span>:-<span class="number">1</span>],<span class="number">16</span>) <span class="comment"># 长度为8*4=32bits，内容为16进制</span></span><br><span class="line">mask = <span class="number">0b10100100000010000000100010010100</span> <span class="comment"># 32bits</span></span><br><span class="line"></span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    tmp=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        (R,out)=lfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; <span class="number">1</span>)^out</span><br><span class="line">    f.write(<span class="built_in">chr</span>(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>下面<strong>细看一下mask的性质</strong></p><ul><li><p>只有第3、5、8、12、20、27、30、32位是1，其它都是0，这就导致如果R的    对应位全不为1，那么i就为0</p></li><li><p>lastbit是由i逐位向前异或的，碰到0可以忽略，所以lastbit最后的值取决于i中1的个数，如果是奇数个1，则lastbit为1；否则lastbit为0。而i中1的奇偶数取决于R的3、5、8、12、20、27、30、32位。</p></li><li><p>于是可以得到线性反馈函数</p><script type="math/tex; mode=display">lastbit=R_3\bigoplus R_3\bigoplus R_5\bigoplus R_8\bigoplus R_{12}\bigoplus R_{20}\bigoplus R_{27}\bigoplus R_{30}\bigoplus R_{32}</script></li></ul><p>下面<strong>开始求解</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = <span class="string">&#x27;10100100000010000000100010010100&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;00100000111111011110111011111000&#x27;</span></span><br><span class="line">tmp = key</span><br><span class="line">R = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    output = <span class="string">&#x27;?&#x27;</span>+key[:<span class="number">31</span>]</span><br><span class="line">    ans= <span class="built_in">int</span>(tmp[-<span class="number">1</span>-i])^<span class="built_in">int</span>(output[-<span class="number">3</span>])^<span class="built_in">int</span>(output[-<span class="number">5</span>])^<span class="built_in">int</span>(output[-<span class="number">8</span>])^<span class="built_in">int</span>(output[-<span class="number">12</span>])^<span class="built_in">int</span>(output[-<span class="number">20</span>])^<span class="built_in">int</span>(output[-<span class="number">27</span>])^<span class="built_in">int</span>(output[-<span class="number">30</span>])</span><br><span class="line">    R += <span class="built_in">str</span>(ans)</span><br><span class="line">    key = <span class="built_in">str</span>(ans) + key[:<span class="number">31</span>]</span><br><span class="line"></span><br><span class="line">R = <span class="built_in">hex</span>(<span class="built_in">int</span>(R[::-<span class="number">1</span>], <span class="number">2</span>))[<span class="number">2</span>::]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag&#123;&#x27;</span>+R+<span class="string">&#x27;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF-Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Cryptography </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOTES-02】StreamCipher-线性同余生成器</title>
      <link href="2021/05/20/a3ad9f5d9c40/"/>
      <url>2021/05/20/a3ad9f5d9c40/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在学习流密码，看CTFWiki的过程中有一些疑问和理解，就记录下来方便之后查阅</p></blockquote><h1 id="Method-One"><a href="#Method-One" class="headerlink" title="Method One"></a>Method One</h1><p>程序的大概意思就是一个猜数游戏，如果连续猜中若干次，就算会拿到 flag，背后的生成相应数的核心代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># generate seed with 64 bits of entropy</span></span><br><span class="line">        self.p = <span class="number">4646704883L</span></span><br><span class="line">        self.x = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        self.y = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">        self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line">        <span class="keyword">return</span> (self.x ^ self.y)</span><br></pre></td></tr></table></figure><p>显然，我们猜出前两轮还是比较容易的，毕竟概率也有 0.25。这里当我们猜出前两轮后，使用 Z3 来求解出初始的 x 和 y，那么我们就可以顺利的猜出剩下的值了。不妨进行一波数学推导</p><p><strong>注：$\bigoplus$表示异或</strong></p><script type="math/tex; mode=display">p = 4646704883\\x_0 = random.randint(0, p)\\y_0 = random.randint(0, p)\\x_1 = (2x_0 + 3) \% p\\y_1 = (3y_0 + 9) \% p\\sol_1 = x_1 \bigoplus y_1\\x_2 = (2x_1 + 3) \% p = (2((2x_0 + 3) \% p) + 3) \% p\\y_2 = (3y_1 + 9) \% p = (3((3x_0 + 9) \% p) + 9) \% p\\sol_2 = x_2 \bigoplus y_2</script><p>思路大概就是，如果能猜到$sol_1$和$sol_2$，就能直接得到$x_0$和$y_0$，如此以来，就能算得所有的值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">s1cor = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>]) <span class="comment"># 运行程序的时候直接附上猜得的两个值</span></span><br><span class="line">s2cor = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">dimVector =<span class="number">35</span> <span class="comment"># <span class="doctag">TODO:</span> 事实上p只有33bits，不知道这里为什么要设成35bits</span></span><br><span class="line">x = BitVec(<span class="string">&#x27;x&#x27;</span>, dimVector)</span><br><span class="line">y = BitVec(<span class="string">&#x27;y&#x27;</span>, dimVector)</span><br><span class="line">p = BitVec(<span class="string">&#x27;p&#x27;</span>,dimVector)</span><br><span class="line">s1 = BitVec(<span class="string">&#x27;s1&#x27;</span>,dimVector)</span><br><span class="line">s2 = BitVec(<span class="string">&#x27;s2&#x27;</span>,dimVector)</span><br><span class="line">s = Solver()</span><br><span class="line">s.add(p == <span class="number">4646704883L</span>)</span><br><span class="line">s.add(s1 == s1cor)</span><br><span class="line">s.add(s2== s2cor)</span><br><span class="line">s.add( ( ( ( <span class="number">2</span> * x + <span class="number">3</span> ) % p ) ^ ( ( <span class="number">3</span> * y + <span class="number">9</span> ) % p ) )==s1)</span><br><span class="line">s.add(( ( ( <span class="number">2</span> * ( ( <span class="number">2</span> * x + <span class="number">3</span> ) % p )  + <span class="number">3</span> ) % p ) ^ ( ( <span class="number">3</span> * ( (  <span class="number">3</span> * y + <span class="number">9</span> ) % p) + <span class="number">9</span> ) % p ) )==s2)</span><br><span class="line"><span class="keyword">while</span> s.check() == sat:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">self.p = <span class="number">4646704883L</span></span><br><span class="line">self.x = x</span><br><span class="line">self.y = y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line"><span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getX</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getY</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.y</span><br><span class="line">m = s.model() <span class="comment"># 解向量</span></span><br><span class="line">pMy = <span class="number">4646704883L</span></span><br><span class="line">myObj = SecurePrng(<span class="built_in">int</span>(<span class="built_in">str</span>(m[x]))%pMy,<span class="built_in">int</span>(<span class="built_in">str</span>(m[y]))%pMy) <span class="comment"># 直接将解传进去，得到下一个结果。事实上这一步是验证解，因为可能有多组解</span></span><br><span class="line">mySol1 = myObj.<span class="built_in">next</span>()</span><br><span class="line">mySol2 = myObj.<span class="built_in">next</span>()</span><br><span class="line"><span class="keyword">if</span> mySol1 == s1cor <span class="keyword">and</span> mySol2 == s2cor <span class="keyword">and</span> <span class="built_in">int</span>(<span class="built_in">str</span>(m[x]))&lt;= pMy <span class="keyword">and</span> <span class="built_in">int</span>(<span class="built_in">str</span>(m[y])) &lt;= pMy :</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;x = &quot;</span> + <span class="built_in">str</span>(m[x]) + <span class="string">&quot; ; y = &quot;</span> + <span class="built_in">str</span>(m[y]) </span><br><span class="line">s.add(Or(x != s.model()[x], y != s.model()[y]))</span><br></pre></td></tr></table></figure><p>下面可以重写PRNG，达到利用的目的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">self.i = <span class="number">0</span></span><br><span class="line">self.p = <span class="number">4646704883L</span></span><br><span class="line">self.x = <span class="number">3714993585</span> % self.p</span><br><span class="line">self.y = <span class="number">2248563082</span> % self.p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="built_in">print</span> self.i</span><br><span class="line">self.i += <span class="number">1</span></span><br><span class="line">self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line"><span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getX</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getY</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.y</span><br></pre></td></tr></table></figure><h1 id="Method-Two"><a href="#Method-Two" class="headerlink" title="Method Two"></a>Method Two</h1><p>上面的方法是很好理解的，但CTFWiki上提供了另外一种方法，目前看来是一种更加值得记录下来，好好理解的方法</p><p>下面是原文摘录</p><blockquote><p>这里我们考虑另外一种方法，<strong>依次从低比特位枚举到高比特位获取 x 的值</strong>，之所以能够这样做，是依赖于这样的观察</p><ul><li>a + b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。<strong>因为第 i 比特位进行运算时，只有可能收到低比特位的进位数值。</strong></li><li>a - b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。<strong>因为第 i 比特位进行运算时，只有可能向低比特位的借位。</strong></li><li>a * b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为这可以视作多次加法。</li><li>a % b = c，c 的第 i 比特位的值只受 a 和 b 该比特位以及更低比特位的影响。因为这可视为多次进行减法。</li><li>a ^ b = c，c 的第 i 比特位的值只受 a 和 b 该比特位的影响。这一点是显而易见的。</li></ul><p><strong>注：个人感觉这个技巧非常有用。</strong></p><p>此外，我们不难得知 p 的比特位为 33 比特位。具体利用思路如下</p><ol><li>首先获取两次猜到的值，这个概率有 0.25。</li><li>依次从低比特位到高比特位依次枚举<strong>第一次迭代后的 x 的相应比特位</strong>。</li><li>根据自己枚举的值分别计算出第二次的值，只有当对应比特位正确，可以将其加入候选正确值。需要注意的是，这里由于取模，所以我们需要枚举到底减了多少次。</li><li>此外，在最终判断时，仍然需要确保对应的值满足一定要求，因为之前对减了多少次进行了枚举。</li></ol></blockquote><p><strong>注：我们主要关注利用思路的第二、三、四三步</strong></p><p>具体利用代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurePrng</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=-<span class="number">1</span>, y=-<span class="number">1</span></span>):</span> <span class="comment"># 题外话，默认值参数真是一个美妙的东西，利用好了可以用来做cache、condition啥的</span></span><br><span class="line">        <span class="comment"># generate seed with 64 bits of entropy</span></span><br><span class="line">        self.p = <span class="number">4646704883L</span>  <span class="comment"># 33bit</span></span><br><span class="line">        <span class="keyword">if</span> x == -<span class="number">1</span>:</span><br><span class="line">            self.x = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.x = x</span><br><span class="line">        <span class="keyword">if</span> y == -<span class="number">1</span>:</span><br><span class="line">            self.y = random.randint(<span class="number">0</span>, self.p)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = (<span class="number">2</span> * self.x + <span class="number">3</span>) % self.p</span><br><span class="line">        self.y = (<span class="number">3</span> * self.y + <span class="number">9</span>) % self.p</span><br><span class="line">        <span class="keyword">return</span> (self.x ^ self.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbiti</span>(<span class="params">num, idx</span>):</span> <span class="comment"># idx表达一个类似长度的量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(num)[-idx - <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    sp = SecurePrng()</span><br><span class="line">    targetx = sp.x</span><br><span class="line">    targety = sp.y</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;we would like to get x &quot;</span>, targetx</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;we would like to get y &quot;</span>, targety</span><br><span class="line"></span><br><span class="line">    <span class="comment"># suppose we have already guess two number</span></span><br><span class="line">    guess1 = sp.<span class="built_in">next</span>()</span><br><span class="line">    guess2 = sp.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">    p = <span class="number">4646704883</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># newx = tmpx*2+3-kx*p</span></span><br><span class="line">    <span class="keyword">for</span> kx, ky <span class="keyword">in</span> product(<span class="built_in">range</span>(<span class="number">3</span>), <span class="built_in">range</span>(<span class="number">4</span>)): <span class="comment"># 双重循环</span></span><br><span class="line">        candidate = [[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># only 33 bit</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>): <span class="comment"># 第三层循环</span></span><br><span class="line">            <span class="comment">#print &#x27;idx &#x27;, i</span></span><br><span class="line">            new_candidate = []</span><br><span class="line">            <span class="keyword">for</span> old, bit <span class="keyword">in</span> product(candidate, <span class="built_in">range</span>(<span class="number">2</span>)): <span class="comment"># 最深双层循环</span></span><br><span class="line">                <span class="comment">#print old, bit</span></span><br><span class="line">                oldx = old[<span class="number">0</span>]</span><br><span class="line">                <span class="comment">#oldy = old[1]</span></span><br><span class="line">                tmpx = oldx | ((bit &amp; <span class="number">1</span>) &lt;&lt; i) <span class="comment"># <span class="doctag">TODO:</span> 这个遍历方法还需要理解...</span></span><br><span class="line">                <span class="comment">#tmpy = oldy | ((bit / 2) &lt;&lt; i)</span></span><br><span class="line">                tmpy = tmpx ^ guess1 <span class="comment"># seed_x与第一次猜测的结果异或，得到的就是seed_y</span></span><br><span class="line">                newx = tmpx * <span class="number">2</span> + <span class="number">3</span> - kx * p + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>) <span class="comment"># <span class="doctag">TODO:</span> 后面判断的时候也加上了这个条件，这不等价于啥也没干？暂时不太懂</span></span><br><span class="line">                newy = tmpy * <span class="number">3</span> + <span class="number">9</span> - ky * p + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>)</span><br><span class="line">                tmp1 = newx ^ newy</span><br><span class="line">                <span class="comment">#print &quot;tmpx:    &quot;, bin(tmpx)</span></span><br><span class="line">                <span class="comment">#print &quot;targetx: &quot;, bin(targetx)</span></span><br><span class="line">                <span class="comment">#print &quot;calculate:     &quot;, bin(tmp1 + (1 &lt;&lt; 40))</span></span><br><span class="line">                <span class="comment">#print &quot;target guess2: &quot;, bin(guess1 + (1 &lt;&lt; 40))</span></span><br><span class="line">                <span class="keyword">if</span> getbiti(guess2 + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>), i) == getbiti( <span class="comment"># 验证条件，并加入候选解</span></span><br><span class="line">                        tmp1 + (<span class="number">1</span> &lt;&lt; <span class="number">40</span>), i):</span><br><span class="line">                    <span class="keyword">if</span> [tmpx] <span class="keyword">not</span> <span class="keyword">in</span> new_candidate:</span><br><span class="line">                        <span class="comment">#print &quot;got one&quot;</span></span><br><span class="line">                        <span class="comment">#print bin(tmpx)</span></span><br><span class="line">                        <span class="comment">#print bin(targetx)</span></span><br><span class="line">                        <span class="comment">#print bin(tmpy)</span></span><br><span class="line">                        new_candidate.append([tmpx])</span><br><span class="line">            candidate = new_candidate</span><br><span class="line">            <span class="comment">#print len(candidate)</span></span><br><span class="line">            <span class="comment">#print candidate</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;candidate x for kx: &quot;</span>, kx, <span class="string">&quot; ky &quot;</span>, ky</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> candidate: <span class="comment"># 依次验证每个候选解是否由线性同余生成器生成</span></span><br><span class="line">            tmpx = candidate[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            tmpy = tmpx ^ guess1</span><br><span class="line">            <span class="keyword">if</span> tmpx &gt;= p <span class="keyword">or</span> tmpx &gt;= p:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            mysp = SecurePrng(tmpx, tmpy)</span><br><span class="line">            tmp1 = mysp.<span class="built_in">next</span>()</span><br><span class="line">            <span class="keyword">if</span> tmp1 != guess2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">print</span> tmpx, tmpy</span><br><span class="line">            <span class="built_in">print</span>(targetx * <span class="number">2</span> + <span class="number">3</span>) % p, (targety * <span class="number">3</span> + <span class="number">9</span>) % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF-Cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Cryptography </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOTES-01】The Elementary of Programming Style</title>
      <link href="2021/05/19/d7392dfa38f0/"/>
      <url>2021/05/19/d7392dfa38f0/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Elementary-of-Programming-Style"><a href="#The-Elementary-of-Programming-Style" class="headerlink" title="The Elementary of Programming Style"></a>The Elementary of Programming Style</h1><blockquote><p>转载自RX师傅的博客<a href="https://www.wootec.top/2019/08/18/The-Elementary-Of-Programming-Style/">The Elementary Of Programming Style - Reverier’s Blog (wootec.top)</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是网上流行的一本绝版书籍,短短几页却浓缩了很多精华.</p><p>即使过了30余年, 其中的思想仍旧在编程时十分有参考价值. 时间挡不住作者的真知灼见.</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote><p>对其中一些内容做了一些注释，方便后面自己看的时候能发现想法的变化</p></blockquote><ul><li><p>把代码写清楚，别耍小聪明。</p><blockquote><p>如果有这种才能，建议出成一个带混淆的逆向题（逃</p></blockquote></li><li><p>想干什么，讲的简单点、直接点。</p><blockquote><p>同上，包括你的命名，函数名，代码结构</p></blockquote></li><li><p>只要有可能，使用库函数。</p><blockquote><p>经常去康康库函数源码，反正我是惊呆了，目前的感受就是在使用python的时候告诉自己，多使用built-in function，能显著简化代码</p></blockquote></li><li><p>避免使用太多的临时变量。</p><blockquote><p>什么tmp啊，temp啊，建议少用点，让人觉得很啰嗦</p></blockquote></li><li><p>“效率”不是牺牲清晰性的理由。</p><blockquote><p>确实，有的时候工程代码和竞赛代码不能一概而论，不要顾此失彼</p></blockquote></li><li><p>让机器去干那些脏活。</p><blockquote><p>emmmmm不解释了，应该懂得</p></blockquote></li><li><p>重复的表达式应该换成函数调用。</p><blockquote><p>这个也是老生常谈了，这样的去重方便了调试，也方便了代码复用</p></blockquote></li><li><p>加上括号、避免歧义。</p><blockquote><p>写c的时候不要因为if后面只有一个表达式就省略大括号</p></blockquote></li><li><p>不要使用含糊不清的变量名。</p><blockquote><p>a, b, c… 完了高血压来了</p></blockquote></li><li><p>把不必要的分支去掉。</p><blockquote><p>这个可能需要一些离散数学的知识，能将一大坨条件判断进行谓词逻辑的等价变换，从而化简分支。事实上很多混淆也是基于这个思路</p></blockquote></li><li><p>使用语言的好特性，不要使用那些糟糕的特性。</p><blockquote><p>目前接触到的语言有限，暂时想到的是python中的各种内置数据结构，可以轻松实现类似有向图的存储等等</p></blockquote></li><li><p>该用逻辑表达式的时候，不要使用过多的条件分支。</p></li><li><p>如果逻辑表达式不好理解，就试着做下变形。</p></li><li><p>选择让程序更简洁的数据表达形式。</p></li><li><p>先用伪代码写，再翻译成你使用的语言。</p><blockquote><p>这就是手写代码的威力啦，不但能用来锻炼对代码的理解，还能用来预构建思路噢</p></blockquote></li><li><p>模块化。使用过程和函数。</p><blockquote><p>建议学习Common Lisp或Scheme类似的极致函数式编程语言，学完感觉看世界都不一样了（虽然我现在有点忘记</p></blockquote></li><li><p>只要你能保证程序的可读性，能不用 goto 就别用 。</p><blockquote><p>逆向中碰到goto的话，会觉得非常莫名其妙，突然就跑飞了。所以同样的，建议出成题目</p></blockquote></li><li><p>不要给糟糕的代码打补丁 - 重写就是了。</p></li><li><p>把大的程序分成一小片一小片来写，分块测试。</p></li><li><p>使用递归程序来处理递归定义的数据结构。</p></li><li><p>正确和错误的输入数据都要测试。</p></li><li><p>确保输入不会超出程序的限制。</p></li><li><p>依靠文件结束来终止输入，而不是依赖一个记数。</p></li><li><p>把文件结束作为一个输入状态来处理。</p></li><li><p>识别出错误的输入；如果有可能就修复它。</p></li><li><p>让输入数据很容易构造出来，让输出数据不言自明。</p></li><li><p>使用统一的输入格式。</p></li><li><p>让输入容易校对。</p></li><li><p>如有可能，提供更自由的输入格式。</p></li><li><p>使用输入提示，允许使用默认值。并把它们显示出来。</p></li><li><p>把输入输出放到子程序里。</p></li><li><p>确保所有的变量在使用前都有初始化。</p></li><li><p>不要因为一个 bug 而停止不前。</p></li><li><p>打开编译程序的调试选项。</p><blockquote><p>对反逆向工程有一点帮助，因为debug模式发布的程序，它的汇编和release版本有很大的差别</p></blockquote></li><li><p>常量结构用数据声明初始化，变量结构用执行代码初始化。</p></li><li><p>小心 off-by-one 错误。</p></li><li><p>当循环中有多个跳出点时要小心。</p></li><li><p>如果什么都不做，那么也要优雅的表现出这个意思。</p></li><li><p>用边界值测试程序。</p><blockquote><p>尽可能刁难你的代码，想一些脑溢血（bushi，才会想到的测试值</p></blockquote></li><li><p>手工检查一些答案。</p><blockquote><p>不管是不是手工吧，你要在脑子里跑一会儿你的程序，以检查时候符合你的预期值</p></blockquote></li><li><p>防御式编程 - 为不可能的情况写几句代码。</p></li><li><p>10.0 乘 0.1 很难保证永远是 1.0 。</p></li><li><p>7/8 等于 0 ，而 7.0/8.0 不等于 0 。</p></li><li><p>不要直接判断两个浮点数相等。</p></li><li><p>先做对，再弄快。</p></li><li><p>先使其可靠，再让其更快。</p></li><li><p>先把代码弄干净，再让它变快。</p></li><li><p>别为了获得一丁点“性能”就牺牲掉整洁。</p></li><li><p>让编译器做些简单的优化。</p><blockquote><p>编译器是很强大的，以gcc为例，有很多关于安全的意想不到的功能</p></blockquote></li><li><p>不要过分追求重用代码；下次用的时候重新组织一下即可。</p></li><li><p>确保特殊的情况是真的特殊。</p><blockquote><p>这个是真的，不要突然考虑到一个情况，就写一个另外的分支；又想到一种情况，又写一个分支…</p></blockquote></li><li><p>保持简洁以获得速度。</p></li><li><p>不要死磕代码来加快速度 - 找个更好的算法。</p></li><li><p>用工具分析你的程序。在做“性能”改进前先评测一下。</p></li><li><p>确保注释和代码一致。</p></li><li><p>不要在注释里仅仅重复代码 - 让每处注释都有价值。</p></li><li><p>不要给糟糕的代码做注释 - 应该重写它。</p><blockquote><p>szyd，至于怎么算糟糕，这个应该能感觉出来吧（</p></blockquote></li><li><p>给变量都起个有意义的名字。</p><blockquote><p>array不如换成src或者dest</p></blockquote></li><li><p>把程序重新整理一下，让阅读代码的人更容易理解。</p><blockquote><p>代码重构是很累的（反正我是这样，但没办法啊，必须得肝</p></blockquote></li><li><p>为你的数据布局写一个文档。</p><blockquote><p>这个暂时没啥想法，类似Android里面的xml？I don’t know…</p></blockquote></li><li><p>不要过分注释。</p><blockquote><p>在《代码简洁之道》中有对于这个的详细解释。因为写的代码一定会有后期维护哒，所以注释不用写得过于详细，比如说对于某个函数，只需要记录他的大致作用就行，而不需要记录诸如，这个变量是干嘛的，那个变量又是干嘛的。因为人都是比较懒的，维护代码的时候，如果你看到的是你一年前写的又臭又长的注释，你会想管它吗？大概率不会。然后受伤的就是用户了</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Style </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programming Style </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-02】MiniL-CTF-2021</title>
      <link href="2021/05/16/e9933c575dd2/"/>
      <url>2021/05/16/e9933c575dd2/</url>
      
        <content type="html"><![CDATA[<h1 id="Mini-L2021"><a href="#Mini-L2021" class="headerlink" title="Mini-L2021"></a>Mini-L2021</h1><p><strong>URL</strong>: <a href="https://ctf.xidian.edu.cn/#/index">https://ctf.xidian.edu.cn/#/index</a></p><p><strong>Team</strong>: cuttl3fish——kyriota | track | TBMK</p><p><strong>Start Time</strong>: 5.06 20:00</p><p><strong>End Time</strong>: 5.12 20:00</p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="web1-easy-java-kyr"><a href="#web1-easy-java-kyr" class="headerlink" title="web1 easy-java | kyr"></a>web1 easy-java | kyr</h3><p>不会java，枯嘞</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">New java.io.BufferedReader(New java.io.FileReader(<span class="string">&quot;/flag&quot;</span>)).readLine()</span><br></pre></td></tr></table></figure><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="抓猫猫-kyr"><a href="#抓猫猫-kyr" class="headerlink" title="抓猫猫 | kyr"></a>抓猫猫 | kyr</h3><blockquote><p> hint：kawaii neko chan says that : what doesn’t kill u makes u stronger</p></blockquote><p>so what u should do is follow what she said , 然后同时连俩 bot 让他们对线，看看谁更腻害</p><h3 id="好白给的签到题-kyr"><a href="#好白给的签到题-kyr" class="headerlink" title="好白给的签到题 | kyr"></a>好白给的签到题 | kyr</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;story.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    fll=flast</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;&#123;&#x27;</span> <span class="keyword">in</span> f <span class="keyword">and</span> <span class="string">b&#x27;&#125;&#x27;</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(f[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        flast=f</span><br><span class="line">        f=base64.b64decode(f)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        flast=fll</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f=base64.b64decode(f[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            f=base64.b64decode(flast[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="土-块-kyr"><a href="#土-块-kyr" class="headerlink" title="土 块 | kyr"></a>土 块 | kyr</h3><p>把题目中的<code>game</code>函数拿出来研究，如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tukuai <span class="keyword">import</span> game</span><br><span class="line">cheat=[[<span class="number">9</span>,[<span class="number">1</span>,<span class="number">0</span>]],[<span class="number">9</span>,[<span class="number">0</span>,<span class="number">1</span>]]]</span><br><span class="line">init_state = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">coin1 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">coin2 = randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">temp = coin1 * <span class="number">2</span> + coin2</span><br><span class="line">init_state[temp] = <span class="number">1</span></span><br><span class="line">servercoin,qc = game(cheat, init_state)</span><br><span class="line"><span class="built_in">print</span>(coin1)</span><br><span class="line"><span class="built_in">print</span>(coin2)</span><br><span class="line"><span class="built_in">print</span>(init_state)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my coin is &#x27;</span> + <span class="built_in">str</span>(servercoin) + <span class="string">&#x27; your coin is?&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_bloch_multivector</span><br><span class="line">display(plot_bloch_multivector(init_state))</span><br><span class="line">simulator=Aer.get_backend(<span class="string">&#x27;qasm_simulator&#x27;</span>)</span><br><span class="line">result=execute(qc,backend=simulator).result()</span><br><span class="line"><span class="keyword">from</span> qiskit.tools.visualization <span class="keyword">import</span> plot_histogram</span><br><span class="line">display(qc.draw(output=<span class="string">&#x27;mpl&#x27;</span>))</span><br><span class="line">display(plot_histogram(result.get_counts(qc)))</span><br></pre></td></tr></table></figure><p>画出几个图出来看看，只要绘出 bot 的输出 = my coin 的量子电路即可，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌──────────────────────┐┌───┐        </span><br><span class="line">q12_0: ┤0                     ├┤ X ├──■─────</span><br><span class="line">       │  initialize(0,0,1,0) │└─┬─┘┌─┴─┐┌─┐</span><br><span class="line">q12_1: ┤1                     ├──■──┤ X ├┤M├</span><br><span class="line">       └──────────────────────┘     └───┘└╥┘</span><br><span class="line"> c1: 1&#x2F;═══════════════════════════════════╩═</span><br><span class="line">                                          0 </span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="0oooops-track"><a href="#0oooops-track" class="headerlink" title="0oooops | track"></a>0oooops | track</h3><blockquote><p>这道题涉及到windows的异常处理机制SEH</p></blockquote><h4 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h4><p>这个题不涉及太多SEH的底层，大概有以下几个点需要了解的：</p><ul><li>SEH实际包含两个主要功能：结束处理（termination handling）和异常处理（exception handling)</li><li>每当你建立一个try块，它必须跟随一个 <code>__finally</code>块或一个<code>__except</code>块。</li><li>一个<code>try</code>块之后不能既有finally块又有except块。但可以在try-except块中嵌套try-finally块，反过来 也可以。</li><li><code>__try</code>,<code>__finally</code>关键字用来标出结束处理程序两段代码的轮廓<br>不管保护体（try块） 是如何退出的。不论你在保护体中使用return，还是goto，或者是longjump，结束处理程序 （finally块）都将被调用。</li><li>在try使用<code>__leave</code>关键字会引起跳转到try块的结尾</li><li>给<code>ms_exc.registration.TryLevel</code>赋值是用于处理嵌套的try</li></ul><blockquote><p>学习自HAPPY师傅的博客</p></blockquote><p>然后看看题，main函数直接看发现异常，于是看汇编，定位到伪代码异常处。IDA的分析结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00412330 loc_412330:                             ; CODE XREF: _main_0+15C↑j</span><br><span class="line">.text:00412330 ;   __try &#123; &#x2F;&#x2F; __except at loc_412377</span><br><span class="line">.text:00412330                 mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:00412337                 lea     ebx, [ebp+Str]</span><br><span class="line">.text:0041233D                 xor     eax, eax</span><br><span class="line">.text:0041233F                 db      3Eh</span><br><span class="line">.text:0041233F                 mov     dword ptr [eax], 0</span><br><span class="line">.text:00412346                 mov     edx, 0</span><br><span class="line">.text:0041234B                 div     edx</span><br></pre></td></tr></table></figure><p>发现非常明显的<strong>除零异常</strong>还有<strong>eax清零后却试图访问它的内存</strong>，以及SEH结构。不需要对它进行任何patch，因为必须让程序捕获到这个异常，才会去执行<code>__except_filter</code>，也就是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text:00412356 loc_412356:                             ; DATA XREF: .rdata:stru_41A238↓o</span><br><span class="line">.text:00412356 ;   __except filter &#x2F;&#x2F; owned by 412330</span><br><span class="line">.text:00412356                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:00412359                 mov     ecx, [eax]</span><br><span class="line">.text:0041235B                 mov     edx, [ecx]</span><br><span class="line">.text:0041235D                 mov     [ebp+var_1BC], edx</span><br><span class="line">.text:00412363                 mov     eax, [ebp+ms_exc.exc_ptr]</span><br><span class="line">.text:00412366                 push    eax</span><br><span class="line">.text:00412367                 mov     ecx, [ebp+var_1BC]</span><br><span class="line">.text:0041236D                 push    ecx</span><br><span class="line">.text:0041236E                 call    sub_411131</span><br><span class="line">.text:00412373                 add     esp, 8</span><br><span class="line">.text:00412376                 retn</span><br></pre></td></tr></table></figure><p>稍微看一看<code>sub_411131</code>函数的内部逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_411DD0</span><span class="params">(<span class="keyword">int</span> a1, _EXCEPTION_POINTERS *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a2-&gt;ExceptionRecord-&gt;ExceptionCode != <span class="number">0xC0000094</span> ) <span class="comment">// 除零异常相应的异常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v5 = (<span class="keyword">char</span> *)(a2-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>);</span><br><span class="line">  qmemcpy(v4, <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] != ((<span class="keyword">unsigned</span> __int8)a2-&gt;ContextRecord-&gt;Eip ^ ((v5[<span class="number">2</span> * i + <span class="number">1</span>] ^ <span class="number">0x4D</span>) - <span class="number">4</span>) ^ <span class="number">0x13</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a2-&gt;ContextRecord-&gt;Eip += <span class="number">54</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a2-&gt;ContextRecord-&gt;Eip += <span class="number">63</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现将运算结果存在v5中，但是只有奇数位，不妨试着还原一下（伪代码）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> magic_1[] = <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_1[i] ^ 0x13 ^ errr_addr)+4)^0x4d);</span></span><br><span class="line">        flag[<span class="number">2</span> * i + <span class="number">1</span>] = ((magic_1[i] ^ <span class="number">0x13</span> ^ errr_addr)+<span class="number">4</span>)^<span class="number">0x4d</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并且如果满足条件，将会改变eip的值，将进程从异常中跳出来，不妨看看跳到了哪里</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">0x41234B</span> + <span class="number">63</span>))</span><br></pre></td></tr></table></figure><p>那里是congratulations的提示信息，但很明显我们还没拿到完整的flag</p><h4 id="VEH-amp-amp-TLS"><a href="#VEH-amp-amp-TLS" class="headerlink" title="VEH &amp;&amp; TLS"></a>VEH &amp;&amp; TLS</h4><p>查看IDA的Exports窗口可以看到TlsCallback_0_0</p><blockquote><p>TLS，Thread Local Storage 线程局部存储，TLS回调函数的调用运行要先于PE代码执行，该特性使它可以作为一种反调试技术使用。</p><p>TLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据。</p></blockquote><p>return了一个奇怪的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID __stdcall <span class="title">TlsCallback_0_0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">return</span> AddVectoredExceptionHandler(<span class="number">1u</span>, Handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attributes: thunk</span></span><br><span class="line"><span class="function">LONG __stdcall <span class="title">Handler</span><span class="params">(struct _EXCEPTION_POINTERS *ExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_411BD0(ExceptionInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">sub_411BD0</span><span class="params">(_EXCEPTION_POINTERS *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+D0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">40</span>]; <span class="comment">// [esp+DCh] [ebp-34h]</span></span><br><span class="line">  DWORD v4; <span class="comment">// [esp+104h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41D015);</span><br><span class="line">  <span class="keyword">if</span> ( a1-&gt;ExceptionRecord-&gt;ExceptionCode != <span class="number">0xC0000005</span> ) <span class="comment">// 不可访问地址相应的异常代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v4 = a1-&gt;ContextRecord-&gt;Ebx + <span class="number">9</span>;</span><br><span class="line">  v3[<span class="number">0</span>] = <span class="number">16</span>;</span><br><span class="line">  v3[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">  v3[<span class="number">2</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">  v3[<span class="number">4</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">  v3[<span class="number">6</span>] = <span class="number">4</span>;</span><br><span class="line">  v3[<span class="number">7</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">8</span>] = <span class="number">11</span>;</span><br><span class="line">  v3[<span class="number">9</span>] = <span class="number">5</span>;</span><br><span class="line">  v3[<span class="number">10</span>] = <span class="number">31</span>;</span><br><span class="line">  v3[<span class="number">11</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">12</span>] = <span class="number">33</span>;</span><br><span class="line">  v3[<span class="number">13</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">14</span>] = <span class="number">72</span>;</span><br><span class="line">  v3[<span class="number">15</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">16</span>] = <span class="number">6</span>;</span><br><span class="line">  v3[<span class="number">17</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">18</span>] = <span class="number">17</span>;</span><br><span class="line">  v3[<span class="number">19</span>] = <span class="number">69</span>;</span><br><span class="line">  v3[<span class="number">20</span>] = <span class="number">5</span>;</span><br><span class="line">  v3[<span class="number">21</span>] = <span class="number">62</span>;</span><br><span class="line">  v3[<span class="number">22</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">23</span>] = <span class="number">24</span>;</span><br><span class="line">  v3[<span class="number">24</span>] = <span class="number">21</span>;</span><br><span class="line">  v3[<span class="number">25</span>] = <span class="number">72</span>;</span><br><span class="line">  v3[<span class="number">26</span>] = <span class="number">46</span>;</span><br><span class="line">  v3[<span class="number">27</span>] = <span class="number">69</span>;</span><br><span class="line">  v3[<span class="number">28</span>] = <span class="number">33</span>;</span><br><span class="line">  v3[<span class="number">29</span>] = <span class="number">31</span>;</span><br><span class="line">  v3[<span class="number">30</span>] = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x1F</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v3[i] != (((*(<span class="keyword">char</span> *)(v4 + <span class="number">2</span> * i) ^ <span class="number">0x37</span>) + <span class="number">4</span>) ^ <span class="number">0x42</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      a1-&gt;ContextRecord-&gt;Eip += <span class="number">66</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a1-&gt;ContextRecord-&gt;Eip += <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Handler显然是第二段解密），因为我实在是太菜了，又查了一下这个函数的功能，发现了另一个异常处理机制VEH</p><p>VEH处理流程</p><blockquote><ul><li>CPU捕获异常信息</li><li>通过KiDispatchException进行分发(EIP=KiUserExceptionDispatcher)</li><li>KiUserExceptionDispatcher调用RtIDispatchException.</li><li>RtIDispatchException查找VEH处理函数链表并调用相关处理函数</li><li>代码返回到KiUserExceptionDispatcher</li><li>调用ZwContinue再次进入0环(ZwContinue调用NtContinue,主要作用就是恢复 TRAPFRAME然后通过_KiServiceExit返回到3环)。</li><li>线程再次返回3环后,从修正后的位置开始执行</li></ul><p>学习自：<a href="https://blog.csdn.net/weixin_42052102/article/details/83540134">https://blog.csdn.net/weixin_42052102/article/details/83540134</a></p></blockquote><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p><strong>这样一来整个流程大致明了了</strong></p><ul><li>VEH抓到<code>0xC0000005</code></li><li>SEH抓到<code>0xC0000094</code></li><li>分别的flag在各自的handler里面</li></ul><p>脚本如下，写的比较乱</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> errr_addr = <span class="number">0x30234B</span>;</span><br><span class="line">    <span class="keyword">char</span> magic_1[] = <span class="string">&quot;!V -&#125;VG-bp&#125;m-nG!b|ra GyGE|Drp D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_1[i] ^ 0x13 ^ errr_addr)+4)^0x4d);</span></span><br><span class="line">        flag[<span class="number">2</span> * i + <span class="number">1</span>] = ((magic_1[i] ^ <span class="number">0x13</span> ^ errr_addr)+<span class="number">4</span>)^<span class="number">0x4d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> magic_2[] = &#123;<span class="number">16</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">4</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">31</span>,<span class="number">46</span>,<span class="number">33</span>,<span class="number">46</span>,<span class="number">72</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">17</span>,<span class="number">69</span>,<span class="number">5</span>,<span class="number">62</span>,<span class="number">46</span>,<span class="number">24</span>,<span class="number">21</span>,<span class="number">72</span>,<span class="number">46</span>,<span class="number">69</span>,<span class="number">33</span>,<span class="number">31</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1f</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c&quot;, ((magic_2[i]^0x42)-4)^0x37);</span></span><br><span class="line">        flag[<span class="number">2</span> * i] = ((magic_2[i]^<span class="number">0x42</span>)<span class="number">-4</span>)^<span class="number">0x37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    <span class="comment">// miniLctf&#123;y0u_a1r4ady_und4rstand_th4_w1nd0ws_exc4pt1On_handl1e_m4chan1sm&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sub-track"><a href="#sub-track" class="headerlink" title="sub | track"></a>sub | track</h3><blockquote><p>傀儡进程</p></blockquote><h4 id="Pre-check"><a href="#Pre-check" class="headerlink" title="Pre_check"></a>Pre_check</h4><p>这题居然让我电脑报毒了，让我康康！（康不懂，爬了</p><p>main函数很混乱，但仔细看能看出一点东西，貌似是创建一个进程，尝试把另一个文件读进来，然后开始执行？还看见一个熟悉的SMC</p><p>看了hint之后搜到了傀儡进程，一个最基本傀儡进程的实现如下</p><ul><li>CreateProcess创建进程，传入参数CREATE_SUSPENDED使进程挂起</li><li>NtUnmapViewOfSection清空新进程的内存数据</li><li>VirtualAllocEx申请新的内存</li><li>WriteProcessMemory向内存写入payload</li><li>SetThreadContext设置入口点</li><li>ResumeThread唤醒进程，执行payload</li></ul><h4 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h4><p>emmm直接调的话，由于各种奇怪的反调试，好像没法成功，于是我打开了010editor，直接把傀儡进程在运行前全都异或回去，并dump出来单独分析</p><p>清晰的main函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main_0</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> input_len; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+0h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [esp+0h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">char</span> input[<span class="number">56</span>]; <span class="comment">// [esp+D0h] [ebp-3Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_40C015);</span><br><span class="line">  <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0x32</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input your flag: &quot;</span>, v5);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="keyword">char</span>)input);</span><br><span class="line">  input_len = <span class="built_in">strlen</span>(input);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)off_40A040(input, input_len) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulation~~~&quot;</span>, v6);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Try again~~~&quot;</span>, v6);</span><br><span class="line">  getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>off_40A040</code>一路往下点，就看到加密逻辑</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> __cdecl <span class="title">sub_4014F0</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+DCh] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_40C015);</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">char</span>)(((*(_BYTE *)(i + a1) ^ <span class="number">0x66</span>) + <span class="number">4</span>) ^ <span class="number">0x55</span>) != byte_40A020[i] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺常规的，直接还原？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic_1 = [<span class="number">0x5A</span>,<span class="number">0x46</span>,<span class="number">0x59</span>,<span class="number">0x46</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x74</span>,<span class="number">0x63</span>,<span class="number">0x47</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x43</span>,<span class="number">0x47</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x5E</span>,<span class="number">0x44</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_1)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(((magic_1[i] ^ <span class="number">0x55</span>) -<span class="number">4</span>) ^ <span class="number">0x66</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># miniLctf&#123;Th1s_1s_th4_fak4_f1ag!&#125;</span></span><br></pre></td></tr></table></figure><p>我aklsjdaiwjdawijdaiwdjqw（</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><p>又是上一题一样的，在Exports里面有<code>TlsCallback_0_0</code></p><p>里面有对于<code>off_40A040</code>的指向进行处理，然后就没啥问题了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic_1 = [<span class="number">0x5A</span>,<span class="number">0x46</span>,<span class="number">0x59</span>,<span class="number">0x46</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x74</span>,<span class="number">0x63</span>,<span class="number">0x47</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x43</span>,<span class="number">0x47</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x5E</span>,<span class="number">0x44</span>,<span class="number">0x03</span>,<span class="number">0x68</span>,<span class="number">0x51</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">fake_flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_1)):</span><br><span class="line">    fake_flag += <span class="built_in">chr</span>(((magic_1[i] ^ <span class="number">0x55</span>) -<span class="number">4</span>) ^ <span class="number">0x66</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_flag)</span><br><span class="line"></span><br><span class="line">magic_2=[<span class="number">0x5A</span>,<span class="number">0x26</span>,<span class="number">0x59</span>,<span class="number">0x26</span>,<span class="number">0x7B</span>,<span class="number">0x5C</span>,<span class="number">0x43</span>,<span class="number">0x51</span>,<span class="number">0x54</span>,<span class="number">0x6D</span>,<span class="number">0x52</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x4C</span>,<span class="number">0x68</span>,<span class="number">0x4C</span>,<span class="number">0x0F</span>,<span class="number">0x68</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x43</span>,<span class="number">0x03</span>,<span class="number">0x4D</span>,<span class="number">0x03</span>,<span class="number">0x4C</span>,<span class="number">0x43</span>,<span class="number">0x0E</span>,<span class="number">0x59</span>,<span class="number">0x50</span>,<span class="number">0x1E</span>,<span class="number">0x1E</span>,<span class="number">0x4A</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(magic_2)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(((magic_2[i] ^ <span class="number">0x66</span>) - <span class="number">4</span>) ^ <span class="number">0x55</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1><p>还是太菜了，虽然是校内rk3，但这分数太惨了，加油加油！</p>]]></content>
      
      
      <categories>
          
          <category> CTF-Competition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WP-01】NPUCTF2020-BabyObfuscation</title>
      <link href="2021/04/21/eec6d01d64db/"/>
      <url>2021/04/21/eec6d01d64db/</url>
      
        <content type="html"><![CDATA[<h1 id="Step-1-查壳"><a href="#Step-1-查壳" class="headerlink" title="Step 1: 查壳"></a>Step 1: 查壳</h1><ol><li>发现是64位程序，无壳</li><li>运行程序提示为”WHERE IS MY KEY!?”</li></ol><h1 id="Step-2-IDA加载初步判断功能"><a href="#Step-2-IDA加载初步判断功能" class="headerlink" title="Step 2: IDA加载初步判断功能"></a>Step 2: IDA加载初步判断功能</h1><p><code>main</code>函数直接F5看的话，是这样一坨浆糊</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">bool</span> v18; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v22; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v26; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v28[<span class="number">68</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> Str[<span class="number">1008</span>]; <span class="comment">// [rsp+130h] [rbp+B0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v30[<span class="number">1008</span>]; <span class="comment">// [rsp+520h] [rbp+4A0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v31[<span class="number">4</span>]; <span class="comment">// [rsp+14E0h] [rbp+1460h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+14F0h] [rbp+1470h]</span></span><br><span class="line">  <span class="keyword">int</span> k; <span class="comment">// [rsp+14F4h] [rbp+1474h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+14F8h] [rbp+1478h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14FCh] [rbp+147Ch]</span></span><br><span class="line"></span><br><span class="line">  _main(argc, argv, envp);</span><br><span class="line">  <span class="built_in">memset</span>(v30, <span class="number">0</span>, <span class="number">0xFA0</span>ui64);</span><br><span class="line">  v30[<span class="number">1000</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v28, <span class="number">0</span>, <span class="number">0x100</span>ui64);</span><br><span class="line">  v28[<span class="number">64</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">64</span>; ++i )</span><br><span class="line">    v28[i] = i + <span class="number">1</span>;</span><br><span class="line">  v31[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">  v31[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">  v31[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">  v31[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">  v30[<span class="number">1004</span>] = <span class="number">2</span>;</span><br><span class="line">  v30[<span class="number">1005</span>] = <span class="number">3</span>;</span><br><span class="line">  v30[<span class="number">1006</span>] = <span class="number">4</span>;</span><br><span class="line">  v30[<span class="number">1007</span>] = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;WHERE IS MY KEY!?&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%32s&quot;</span>, Str);</span><br><span class="line">  v32 = <span class="built_in">strlen</span>(Str);</span><br><span class="line">  v3 = F0X1(v28[j], v28[j]);</span><br><span class="line">  <span class="keyword">for</span> ( j = v3 / v28[j]; j &lt;= v32; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (v28[j] + v28[j + <span class="number">1</span>]) * (v28[j] + v28[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt;= (<span class="keyword">int</span>)(F0X5(<span class="number">2</span>, <span class="number">2</span>) * v28[j] * v28[j + <span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = ~Str[(<span class="keyword">int</span>)F0X4(j, <span class="number">1</span>)];</span><br><span class="line">      v6 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] = ~(v5 + v31[v6 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = F0X1(v28[j], v28[j + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; (<span class="keyword">int</span>)F0X1(v28[j + <span class="number">1</span>], ~(~v28[j + <span class="number">1</span>] + v28[j])) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v30[j];</span><br><span class="line">      v9 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] = ~(~v8 + v28[v9 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]) * v8;</span><br><span class="line">    &#125;</span><br><span class="line">    v10 = v28[j + <span class="number">1</span>];</span><br><span class="line">    v11 = F0X5(<span class="number">2</span>, <span class="number">1</span>) * v10;</span><br><span class="line">    v12 = v28[j];</span><br><span class="line">    v13 = F0X5(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    v14 = F0X1(v12 * v13, v11);</span><br><span class="line">    v15 = F0X5(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v14 == v15 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X1(v28[j], v28[j + <span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] ^= v31[v16 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = F0X5(V0X3, v28[j]);</span><br><span class="line">    v18 = v17 &lt; v28[j] + <span class="number">1</span>;</span><br><span class="line">    v19 = F0X5(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)F0X3(v19 &gt;= j, v18) )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = ~Str[(<span class="keyword">int</span>)F0X4(j, <span class="number">1</span>)];</span><br><span class="line">      v21 = F0X4(j, <span class="number">1</span>);</span><br><span class="line">      v30[j] ^= ~(v20 + v31[v21 % (<span class="keyword">int</span>)F0X5(<span class="number">2</span>, <span class="number">2</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    v22 = F0X5(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    v23 = F0X1(v28[j], v28[j]);</span><br><span class="line">    v30[j] *= v22 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X5(<span class="number">2</span>, v23 / v28[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  v24 = F0X5(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)F0X4(v24, <span class="number">1</span>) != v32 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  v25 = F0X1(v28[k], v28[k]);</span><br><span class="line">  <span class="keyword">for</span> ( k = v25 / v28[k]; k &lt;= v32; ++k )</span><br><span class="line">  &#123;</span><br><span class="line">    v26 = v30[k];</span><br><span class="line">    <span class="keyword">if</span> ( v26 == (<span class="keyword">int</span>)F0X4(A0X6[k], <span class="number">1</span>) / <span class="number">10</span> )</span><br><span class="line">      ++V0X2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( V0X2 == v32 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nPASS&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_23:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nDENIED&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看<code>F0X1</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">    result = F0X1(a2, (<span class="keyword">int</span>)a1 % a2);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = a1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个递归函数容易发现是在求a1和a2的最大公因数gcd</p><p>然后是<code>F0X5</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X5</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (a2 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      v4 *= a1;</span><br><span class="line">    a1 *= a1;</span><br><span class="line">    a2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也比较容易看出来，就是在求a1的a2次方pow</p><p>接着是<code>F0X4</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">F0X4</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)~(~a1 + a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于两个int而言，这个结构等价于a1-a2</p><p>继续看<code>F0X3</code>和<code>F0X2</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall F0X3(bool a1, bool a2)</span><br><span class="line">&#123;</span><br><span class="line">  char v2; &#x2F;&#x2F; bl</span><br><span class="line">  char v3; &#x2F;&#x2F; al</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; F0X2(a2, a2);</span><br><span class="line">  v3 &#x3D; F0X2(a1, a1);</span><br><span class="line">  return F0X2(v3, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_BOOL8 __fastcall F0X2(char a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  return a1 &#x3D;&#x3D; a2 &amp;&amp; a1 !&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个需要稍微推导一下，可以看出等价于a1&amp;a2</p><blockquote><p>对于函数的功能，可以考虑复制下来，然后测试一下，再结合推导，就能比较容易的判断出函数的功能了</p></blockquote><p>于是进行重命名</p><p><img src="https://i.loli.net/2021/04/21/lneU2O8a6YhrpVC.png" alt="p1.png"></p><h1 id="Step-3-判断条件跳转"><a href="#Step-3-判断条件跳转" class="headerlink" title="Step 3: 判断条件跳转"></a>Step 3: 判断条件跳转</h1><ul><li><p>第一处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v4 = (v28[j] + v28[j + <span class="number">1</span>]) * (v28[j] + v28[j + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ( v4 &gt;= (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2</span>) * v28[j] * v28[j + <span class="number">1</span>]) )</span><br></pre></td></tr></table></figure><p>抽象出来即</p><script type="math/tex; mode=display">(x + y) ^ 2 \ge 4xy</script><p>这是永真的，也就是下面的代码块永远会被执行</p></li><li><p>第二处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v7 = gcd(v28[j], v28[j + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> ( v7 &gt; (<span class="keyword">int</span>)gcd(v28[j + <span class="number">1</span>], ~(~v28[j + <span class="number">1</span>] + v28[j])) )</span><br></pre></td></tr></table></figure><p>等价于</p><script type="math/tex; mode=display">gcd(x, y) > gcd(y, x-y)</script><p>左右两边显然是一样的，所以下面的代码块不可能执行</p></li><li><p>第三处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v10 = v28[j + <span class="number">1</span>];</span><br><span class="line">v11 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>) * v10;</span><br><span class="line">v12 = v28[j];</span><br><span class="line">v13 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">v14 = gcd(v12 * v13, v11);</span><br><span class="line">v15 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ( v14 == v15 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)gcd(v28[j], v28[j + <span class="number">1</span>]) )</span><br></pre></td></tr></table></figure><p>等价于</p><script type="math/tex; mode=display">gcd(2x, 2y) = 2gcd(x, y)</script><p>这也是永真的，故下面的代码块一定执行</p></li><li><p>第四处</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v17 = <span class="built_in">pow</span>(V0X3, v28[j]);</span><br><span class="line">v18 = v17 &lt; v28[j] + <span class="number">1</span>;</span><br><span class="line">v19 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)AND(v19 &gt;= j, v18) )</span><br><span class="line"><span class="comment">//其中V0X3 == 3</span></span><br><span class="line"><span class="comment">//这里需要看看后面关于整个key长度的判断，这里就不说明了</span></span><br></pre></td></tr></table></figure><p>key长度是15故<code>v19 &gt;= j</code>必定成立</p><p>于是只需判断</p><script type="math/tex; mode=display">f(x)=3^x - x - 1 <0</script><p>求导或者直接画图都能判断出该条件为假，则下面的代码块不会执行</p></li><li><p><strong>综上</strong></p><p>只有三处代码有效</p><p><img src="https://i.loli.net/2021/04/21/i19yFkjOEmha56R.png" alt="p2.png"></p></li></ul><p>最终是这样的效果</p><h1 id="Step-4-exp"><a href="#Step-4-exp" class="headerlink" title="Step 4: exp"></a>Step 4: exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enc = [<span class="number">780</span>, <span class="number">780</span>, <span class="number">850</span>, <span class="number">590</span>, <span class="number">800</span>, <span class="number">640</span>, <span class="number">1150</span>, <span class="number">460</span>, <span class="number">980</span>, <span class="number">960</span>, <span class="number">1170</span>, <span class="number">530</span>, <span class="number">970</span>, <span class="number">1080</span>, <span class="number">1250</span>]</span><br><span class="line">vec = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    enc[i] = enc[i] // <span class="number">10</span>;</span><br><span class="line">    enc[i] ^= vec[i%<span class="number">4</span>]</span><br><span class="line">    enc[i] += vec[i%<span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(enc[i]), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h1>]]></content>
      
      
      <categories>
          
          <category> CTF-Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Reverse </tag>
            
            <tag> WP </tag>
            
            <tag> BUUOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>whoami</title>
      <link href="2021/04/14/2390e06bacb2/"/>
      <url>2021/04/14/2390e06bacb2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">track</span><br></pre></td></tr></table></figure><p>来自XDSEC的大一逆向工程菜鸡</p><p>正努力追赶带佬们的脚步</p>]]></content>
      
      
      
        <tags>
            
            <tag> 简介 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
